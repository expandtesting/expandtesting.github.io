[{"categories":null,"contents":"Description Playwright est un outil open source d\u0026rsquo;automatisation des tests d\u0026rsquo;acceptation pour les applications web.\nCet outil permet de tester les applications développées avec les technologies standards telles que HTML5, CSS et JavaScript, mais il est également capable de tester les applications web conçues avec les frameworks modernes tels que Reactjs , Angularjs et Vuejs .\nPlaywright se distingue par plusieurs caractéristiques :\nOpen source / Gratuit Cross-browser : Il offre un support pour plusieurs types de navigateurs tels que Chrome, Firefox, Opera, etc. Une communauté dynamique Documentation disponible dans plusieurs langues Multilingue : Playwright supporte plusieurs langages de programmation tels que JavaScript, C# .Net, Java et Python. Cette formation Playwright vous permettra d\u0026rsquo;acquérir et de maîtriser plusieurs concepts essentiels et avancés de l\u0026rsquo;automatisation des tests web.\nObjectifs pédagogiques À l\u0026rsquo;issue de cette formation d\u0026rsquo;automatisation des tests web avec Playwright, le participant sera en mesure de :\nComprendre l\u0026rsquo;architecture de l\u0026rsquo;outil Open Source Playwright Apprendre à utiliser les fonctionnalités les plus intéressantes de Playwright Concevoir des tests web automatisés avec Playwright Comprendre comment intégrer les tests web avec Playwright dans une chaîne de livraison continue (CI/CD) Public concerné Testeurs ou développeurs désirant se former aux techniques d\u0026rsquo;automatisation des tests web avec Playwright QA Managers, QA Lead Prérequis Connaissances fondamentales du langage JavaScript / TypeScript Connaissances fondamentales en tests web et fonctionnels Notes importantes : Le contenu de la formation ainsi que sa durée peuvent être personnalisés en fonction de vos besoins.\nN\u0026rsquo;hésitez pas à nous contacter pour toute demande sur mesure.\nProgramme de la formation Le programme de cette formation est composé de plusieurs modules allant des notions de base aux notions avancées\nModule 1: Introduction aux tests logiciels Tests manuels / Tests automatisés Les différents types de tests La pyramide de tests Les avantages et les inconvénients de l’automatisation Le pattern 3A pour les tests automatisés Les terminologies DOM et HTML Module 2: Introduction a Playwright Le projet Playwright Architecture de Playwright Principe de fonctionnement de Playwright Module 3: Installation et configuration Conditions préalables (IDE: Vscode / Javascript / NodeJS) Installation des plugins d’aide à l’automatisation Module 4: Les concepts fondamentaux de Playwright Premier exemple (HelloPlaywright)\nLa structure d’un projet de test Playwright Les dépendances nécessaires Le fichier de configuration playwright.config.js / playwright.config.ts Exécution des tests et débogage (debugging) :\nExécution des tests en mode UI Exécution des tests en mode CLI Exécution des tests en mode debug Utilisation de Playwright Inspector Débogage avec Trace Viewer Les concepts de context (browser context)\nLes principales commandes de Playwright\nLes Assertions:\nAuto-retrying assertions Non-retrying assertions (values assertions Soft assertions Module 5: Les interactions avec les éléments web Les différents types de sélecteur web getByRole() , getByText() , getByLabel() , getByPlaceholder(), getByAltText() , getByTitle() , getByTestId() , legacy locator, etc L\u0026rsquo;outil xpath/css tester Exemples pratiques: “Text Box” ”Check Box” ”Radio Button” “Drop Down” Module 6: Les concepts avancés de Playwright Utilisation du context Alerts Popup Alert Confirmation Alert Prompt Exécution JavaScript \u0026ldquo;Click Operation\u0026rdquo; \u0026ldquo;Mocking\u0026rdquo; \u0026ldquo;Clock\u0026rdquo; Exemple d’un scenario e2e: Webpark app Manipulation des dates Multiple forms ScrollUp/ScrollDown Frames Windows ScreenShot \u0026ldquo;File Upload/File Download\u0026rdquo; Actions \u0026ldquo;Drag and Drop\u0026rdquo; \u0026ldquo;Mouseover Action\u0026rdquo; \u0026ldquo;Right Click / Double Click\u0026rdquo; \u0026ldquo;Multiple Actions\u0026rdquo; Tables Links Tooltip Autocomplete Interception Réseaux (Network Requests) Module 7 : Framework d\u0026rsquo;automatisation de tests web Introduction aux concepts du framework Les différentes couches nécessaires : La couche \u0026ldquo;Test Cases\u0026rdquo; La couche \u0026ldquo;DSL\u0026rdquo; La couche \u0026ldquo;Driver\u0026rdquo; La couche \u0026ldquo;SUT\u0026rdquo; Le pattern \u0026ldquo;Page Object Model\u0026rdquo; Structure Globale Exemple pratique Mini Projet (Notes App): Conception Framework Utilisation du Pattern POM Multiples scenarios e2e (Auth, Operations CRUD) Bonnes Pratiques Module 8 : Le reporting Les caractéristiques d\u0026rsquo;un bon rapport de tests Les différentes options et outils de reporting Le reporting natif de Playwright Le reporting avec Allure Report Module 9 : L\u0026rsquo;intégration Continue / pipelines CI/CD Introduction aux concepts d\u0026rsquo;intégration et livraison continues (pipelines CI/CD) Présentation du CircleCI / GitHub Actions Intégration du projet de tests dans le pipelines CI/CD Module 10 : Le mot de la fin Synthèse Partage de ressources / docs / Articles sur le framework Playwright Si vous avez des suggestions d\u0026rsquo;amélioration pour cette formation Playwright n\u0026rsquo;hésitez pas à nous contacter !\n","permalink":"https://expandtesting.com/formations/tests-web-playwright/","tags":null,"title":"Formation Playwright - Automatisation des tests d'acceptation"},{"categories":null,"contents":" Description JavaScript est l\u0026rsquo;un des langages de programmation les plus populaires au monde et connaît une croissance plus rapide que tout autre langage de programmation.\nAujourd\u0026rsquo;hui, JavaScript permet de développer des applications web avec des technologies modernes comme ReactJS, Angular, etc.\nJavaScript est également utilisé pour développer des API robustes, sécurisées et rapides.\nPar ailleurs, JavaScript a sa place dans le développement d\u0026rsquo;applications mobiles avec des technologies comme React Native, et il est également utilisé dans le domaine des objets connectés.\nEn tant qu\u0026rsquo;ingénieur qualité spécialisé en automatisation des tests, JavaScript vous permet d\u0026rsquo;automatiser les tests logiciels grâce à des frameworks robustes, fiables et modernes comme Cypress, Playwright, Selenium.\nCette formation JavaScript et Node.js vous permettra d’acquérir et de maîtriser les concepts fondamentaux de la programmation en langage JavaScript orienté automatisation des tests.\nObjectifs pédagogiques À l\u0026rsquo;issue de cette formation JavaScript, le participant sera en mesure de :\nApprendre les fondamentaux de la programmation en JavaScript avec Node.js Concevoir des tests automatisés avec Mocha et ChaiJS Se familiariser avec des librairies très populaires comme Mocha, ChaiJS, etc. Se préparer pour une utilisation efficace des frameworks d\u0026rsquo;automatisation modernes comme Cypress et Playwright Public concerné Testeurs ou développeurs désirant se former aux fondamentaux de la programmation en JavaScript avec Node.js QA Managers, QA Lead Prérequis Connaissance de base en programmation Programme de la formation Le programme de cette formation est composé de plusieurs modules allant des notions de base aux notions avancées\nModule 1: Introduction à l\u0026rsquo;écosystème Node.js / JavaScript JavaScript et les navigateurs web JavaScript et Node.js Architecture de Node.js Les outils CLI de Node.js npm, npx Module 2: Installation Installation standard de Node.js Installation avec nvm Installation de Visual Studio Code (VSCode) Installation de plugins supplémentaires Module 3: Les bases de JavaScript Les variables Les constantes Les différents types de données Le mode \u0026ldquo;strict\u0026rdquo; Les objets Introduction aux tableaux Les fonctions Module 4: Les opérateurs Les opérateurs d\u0026rsquo;assignation Les opérateurs arithmétiques Les opérateurs de comparaison Les opérateurs d\u0026rsquo;équivalence (Equality Operators) Les opérateurs logiques Les opérateurs \u0026ldquo;Bitwise\u0026rdquo; Module 5: Le contrôle de flux (Control Flow) \u0026ldquo;if … else\u0026rdquo; \u0026ldquo;Switch\u0026hellip;case\u0026rdquo; \u0026ldquo;For\u0026rdquo; \u0026ldquo;While\u0026rdquo; \u0026ldquo;Do\u0026hellip;while\u0026rdquo; \u0026ldquo;Infinite Loops\u0026rdquo; \u0026ldquo;For\u0026hellip;in\u0026rdquo; \u0026ldquo;For\u0026hellip;of\u0026rdquo; Module 6: Les tableaux Déclaration, initialisation Ajout d\u0026rsquo;éléments Recherche d\u0026rsquo;éléments Suppression d\u0026rsquo;éléments Filtrage des éléments Organisation des éléments \u0026ldquo;Mapping\u0026rdquo; des éléments Module 7: Introduction aux concepts OOP avec JavaScript Les objets Les classes Les fonctions Module 8: La programmation asynchrone Concepts de la programmation asynchrone La syntaxe async/await Module 9: I/O Manipulation des fichiers Requêtes HTTP Module 10: Mocha Introduction au framework Mocha Utilisation des hooks de Mocha Module 11: ChaiJS Introduction au framework Chai Utilisation des assertions les plus communes Module 12 : Le mot de la fin Synthèse Partage de ressources / docs / Articles sur la programmation en JavaScript Nous avons créé cet outil en ligne pour avoir un envirenement pour pratiquer js en quelques minutes JavaScript, Mocha, Chai, and Sinon Player pour soutenir cette formation.\nSi vous avez des suggestions d\u0026rsquo;amélioration pour cette formation JavaScript n\u0026rsquo;hésitez pas à nous contacter !\n","permalink":"https://expandtesting.com/formations/fondamentaux-javascript-nodejs/","tags":null,"title":"Formation JavaScript - Les fondamentaux de la programmation"},{"categories":null,"contents":"Description Selenium WebDriver est un outil open source d\u0026rsquo;automatisation des tests d\u0026rsquo;acceptation pour les applications web.\nCet outil permet de tester les applications développées avec les technologies standards telles que HTML5, CSS et JavaScript, mais il est également capable de tester les applications web conçues avec les frameworks modernes tels que Reactjs , Angularjs et Vuejs .\nLa version Selenium 4.x est publiée avec plusieurs nouvelles fonctionnalités et des améliorations significatives.\nSelenium se distingue par plusieurs caractéristiques :\nOpen source / Gratuit Maturité : Il s\u0026rsquo;agit de l\u0026rsquo;un des outils les plus anciens et est largement adopté par de nombreuses organisations. Cross-browser : Il offre un support pour plusieurs types de navigateurs tels que Chrome, Firefox, Opera, etc. Une communauté dynamique Documentation disponible dans plusieurs langues Multilingue : Selenium supporte plusieurs langages de programmation tels que Java, C#, JavaScript, Python, Ruby. Cette formation Selenium WebDriver 4.x vous permettra d\u0026rsquo;acquérir et de maîtriser plusieurs concepts essentiels et avancés de l\u0026rsquo;automatisation des tests web.\nObjectifs pédagogiques À l\u0026rsquo;issue de cette formation d\u0026rsquo;automatisation des tests web avec Selenium WebDriver, le participant sera en mesure de :\nComprendre l\u0026rsquo;architecture de l\u0026rsquo;outil Open Source Selenium Apprendre à utiliser les fonctionnalités les plus intéressantes de Selenium Concevoir des tests web automatisés avec Selenium Comprendre comment intégrer les tests web avec Selenium dans une chaîne de livraison continue (CI/CD) Public concerné Testeurs ou développeurs désirant se former aux techniques d\u0026rsquo;automatisation des tests web avec Selenium QA Managers, QA Lead Prérequis Connaissances fondamentales du langage Java Connaissances fondamentales en tests web et fonctionnels Programme de la formation Le programme de cette formation est composé de plusieurs modules allant des notions de base aux notions avancées\nModule 1: Introduction aux tests logiciels Tests manuels / Tests automatisés Les différents types de tests La pyramide de tests Les avantages et les inconvénients de l’automatisation Le pattern 3A pour les tests automatisés Les terminologies DOM et HTML Module 2: Introduction a Selenium WebDriver Le projet Selenium L\u0026rsquo;écosystème Selenium (Composants / fonctionnalités) Selenium IDE Selenium Webdriver Selenium Grid Selenium API Selenium 4: Les nouvelles fonctionnalités Le standard W3C Webdriver WebDriver BiDi Architecture de Selenium Webdriver Classic Architecture de Selenium Webdriver BIDI Principe de fonctionnement de Selenium WebDriver Module 3: Installation et configuration de l\u0026rsquo;environnement de développement Installation et configuration du JDK (Java) Installation des drivers chromedriver / geckodriver Installation des plugins d’aide à l’automatisation Installation et configuration de l\u0026rsquo;outil de build Gradle Installation d\u0026rsquo;IntelliJ Module 4: Les concepts fondamentaux de Selenium Premier exemple (HelloSelenium) La structure d’un projet de test en java Les dépendances nécessaires Les drivers (chromedriver, geckodriver) La session WebDriver Les options de sessions / capabilities: Options pour chrome Options pour firefox Les principales commandes browser (Navigate, Forward, Back, Refresh, etc) Module 5: Les interactions avec les éléments web Les différents types de sélecteur web Id, name, css, xpath, classname, tagName, linkText, partiallyLinkText, etc L\u0026rsquo;outil xpath/css tester Explication du Weblement Exemples pratiques: “Text Box” ”Check Box” ”Radio Button” “Drop Down” Module 6 : Les stratégies d’attentes La stratégie “Static waits” La stratégie “Implicit waits” La stratégie “Explicit waits” La stratégie “Fluent waits” Module 7: Les concepts avancés de Selenium Utilisation du context Alerts Popup Alert Confirmation Alert Prompt Exécution JavaScript “Click Operation” “Scrolling“ “WebElement Highlighting“ Exemple d’un scenario e2e: Webpark app Manipulation des dates Multiple forms ScrollUp/ScrollDown Frames Windows ScreenShot “File Upload/File Download“ Actions “Drag and Drop” “Mouseover Action” “Right Click / Double Click” “Multiple Actions” Tables Links Tooltip Autocomplete Interception Réseaux (Network Requests) (BIDI) Récupération log navigateur (BIDI) Module 8 : Tests NG Introduction à TestNG (le quoi et pourquoi) Les différentes \u0026ldquo;Annotations\u0026rdquo; de TestNG L\u0026rsquo;exécution des tests avec le fichier testng.xml L\u0026rsquo;exécution de plusieurs fichiers en même temps La gestion de la priorité des tests (dependsOnMethods, etc.) L\u0026rsquo;utilisation des paramètres avec TestNG Les \u0026ldquo;DataProviders\u0026rdquo; Concepts avancés : \u0026ldquo;Grouping, Listeners\u0026rdquo; L\u0026rsquo;exécution des tests en parallèle avec TestNG Module 9 : Gradle Introduction à l\u0026rsquo;outil Gradle Les concepts fondamentaux de Gradle Les commandes du build essentials avec Gradle Module 10 : Framework d\u0026rsquo;automatisation de tests web Introduction aux concepts du framework Les différentes couches nécessaires : La couche \u0026ldquo;Test Cases\u0026rdquo; La couche \u0026ldquo;DSL\u0026rdquo; La couche \u0026ldquo;Driver\u0026rdquo; La couche \u0026ldquo;SUT\u0026rdquo; Le pattern \u0026ldquo;Page Object Model\u0026rdquo; Structure Globale Exemple pratique Mini Projet (Notes App): Conception Framework Utilisation du Pattern POM Multiples scenarios e2e (Auth, Operations CRUD) Bonnes Pratiques Module 11 : Le reporting Les caractéristiques d\u0026rsquo;un bon rapport de tests Les différentes options et outils de reporting Le reporting avec \u0026ldquo;Allure Report\u0026rdquo; Module 12 : L\u0026rsquo;intégration Continue / pipelines CI/CD Introduction aux concepts d\u0026rsquo;intégration et livraison continues (pipelines CI/CD) Présentation du CircleCI / GitHub Actions Intégration du projet de tests dans le pipelines CI/CD Module 13 : Le mot de la fin Synthèse Partage de ressources / docs / Articles sur le framework Selenium Si vous avez des suggestions d\u0026rsquo;amélioration pour cette formation Selenium WebDriver n\u0026rsquo;hésitez pas à nous contacter !\n","permalink":"https://expandtesting.com/formations/tests-web-selenium-webdriver/","tags":null,"title":"Formation Selenium WebDriver - Automatisation des tests d'acceptation"},{"categories":null,"contents":"Description K6 est un outil open source de tests de performance. C\u0026rsquo;est un outil gratuit, puissant et extensible. Il se démarque des autres outils par sa simplicité d\u0026rsquo;utilisation, sa documentation complète et ses fonctionnalités uniques.\nL\u0026rsquo;outil K6 est développé en langage GO, les scripts d\u0026rsquo;automatisation des tests de performance s\u0026rsquo;écrivent en JavaScript (possible également avec TypeScript), ce qui simplifie énormément la prise en main de cet outil.\nIl est également possible d\u0026rsquo;intégrer K6 avec les outils modernes de monitoring comme Datadog , Grafana , etc.\nK6 permet de gérer plusieurs types de tests de performance:\nSmoke Tests Load Tests Soak Tests Spike Tests Cette formation K6 vous permettra d\u0026rsquo;acquérir et de maîtriser les concepts clés de l\u0026rsquo;automatisation des tests de performance avec l\u0026rsquo;outil K6.\nObjectifs pédagogiques À l\u0026rsquo;issue de cette formation d\u0026rsquo;automatisation des tests de performance avec K6, le participant sera en mesure de :\nComprendre l\u0026rsquo;architecture de l\u0026rsquo;outil Open Source K6 Apprendre à utiliser les fonctionnalités les plus intéressantes de K6 Concevoir des tests de performance automatisés avec K6 Comprendre comment intégrer les tests de performance avec K6 dans une chaîne de livraison continue Public concerné Testeurs Développeurs Ops QA Managers, QA Lead Prérequis Connaissances fondamentales en JavaScript Connaissances fondamentales en tests de performance Programme de la formation Le programme de cette formation est composé de plusieurs modules allant des notions de base aux notions avancées\nContactez-nous pour en savoir plus sur cette formation !\nSi vous avez des suggestions d\u0026rsquo;amélioration pour cette formation K6 n\u0026rsquo;hésitez pas à nous contacter !\n","permalink":"https://expandtesting.com/formations/tests-performance-k6/","tags":null,"title":"Formation K6 - Automatisation des tests de performance"},{"categories":null,"contents":"Description Appium est un framework open source d\u0026rsquo;automatisation des tests mobiles conçu pour simplifier et accélérer l\u0026rsquo;automatisation des tests d\u0026rsquo;applications mobiles natives (iOS, Android) ainsi que des applications mobiles hybrides développées avec des technologies telles que React Native .\nEn plus des tests mobiles (Android, iOS), Appium offre la possibilité d\u0026rsquo;automatiser les tests d\u0026rsquo;acceptation pour les applications desktop Windows et MacOS.\nLe framework Appium se distingue des autres outils et frameworks d\u0026rsquo;automatisation grâce à son architecture multiplateforme, ses divers drivers (uiautomator2, xcuitest, flutter, chromium, espresso, mac2, safari, etc.) et ses plugins qui simplifient et accélèrent l\u0026rsquo;automatisation et l\u0026rsquo;industrialisation des tests mobiles.\nAppium supporte plusieurs langages de programmation tels que Java, C#, JavaScript (WebdriverIO), Python, Ruby.\nAvec la version 2 d\u0026rsquo;Appium, l\u0026rsquo;installation, la mise à jour et le développement des drivers et plugins deviennent plus confortables.\nCette formation Appium vous permettre d\u0026rsquo;acquérir et de maîtriser plusieurs concepts essentiels et avancés de l\u0026rsquo;automatisation des tests mobiles.\nObjectifs pédagogiques À l\u0026rsquo;issue de cette formation d\u0026rsquo;automatisation des tests mobile avec Appium, le participant sera en mesure de :\nComprendre l\u0026rsquo;architecture de l\u0026rsquo;outil Open Source Appium Apprendre à utiliser les fonctionnalités les plus intéressantes d\u0026rsquo;Appium Concevoir des tests mobiles automatisés avec Appium Comprendre comment intégrer les tests mobiles avec Appium dans une chaîne de livraison continue (CI/CD) Public concerné Testeurs ou développeurs désirant se former aux techniques d\u0026rsquo;automatisation des tests mobiles avec Appium QA Managers, QA Lead Prérequis Connaissances fondamentales du langage Java Connaissances fondamentales en tests mobiles/fonctionnels Programme de la formation Le programme de cette formation est composé de plusieurs modules allant des notions de base aux notions avancées\nModule 1 : Les concepts fondamentaux d\u0026rsquo;Appium Introduction aux différents types et technologies d\u0026rsquo;applications mobiles L\u0026rsquo;automatisation des tests mobiles et la pyramide de tests Introduction au pattern 3A Introduction au Framework Appium Écosystème Appium V2 (Drivers, Plugins, W3C) Architecture globale d\u0026rsquo;Appium Architecture d\u0026rsquo;Appium pour Android Architecture d\u0026rsquo;Appium pour iOS Principe du fonctionnement d\u0026rsquo;Appium (How Appium works?) Présentation de l\u0026rsquo;application Android qui sera utilisée dans les ateliers pratiques Module 2 : Installation et configuration de l\u0026rsquo;environnement de développement Installation et configuration du JDK (Java) Installation et configuration de l\u0026rsquo;SDK Android (Android Studio) Installation et configuration de l\u0026rsquo;outil de build Gradle Installation d\u0026rsquo;IntelliJ Installation de nodeJS Installation d\u0026rsquo;Appium V2 Installation des différents modules nécessaires à Appium V2 (drivers, plugins) Installation de l\u0026rsquo;outil Appium Inspector (Appium V2) Module 3 : Les \u0026ldquo;Capabilities\u0026rdquo; d\u0026rsquo;Appium Introduction aux sessions d\u0026rsquo;automatisation d\u0026rsquo;Appium Les “Capabilities“ communes Les \u0026ldquo;Capabilities\u0026rdquo; spécifiques à la plateforme Android Les \u0026ldquo;Capabilities\u0026rdquo; spécifiques à la plateforme iOS Module 4 : Les stratégies d\u0026rsquo;identification d\u0026rsquo;éléments UI (Element Locator Strategies) Explication du concept du \u0026ldquo;Locator\u0026rdquo; et de la \u0026ldquo;Strategy\u0026rdquo; Les stratégies d\u0026rsquo;identification les plus utilisées (accessibility id, ID Name, class Name, Xpath, etc.) Les stratégies avancées Les stratégies les plus recommandées et les raisons Les limites de certaines stratégies L\u0026rsquo;outil Appium Inspector Les méthodes findElement, findElements Cas d\u0026rsquo;utilisation des différentes stratégies Module 5 : Les stratégies d\u0026rsquo;attentes La stratégie \u0026ldquo;Static waits\u0026rdquo; La stratégie \u0026ldquo;Implicit waits\u0026rdquo; La stratégie \u0026ldquo;Explicit waits\u0026rdquo; Module 6 : Automatisation des \u0026ldquo;Gestures\u0026rdquo; et \u0026ldquo;Touch Actions\u0026rdquo; La différence entre les \u0026ldquo;Input\u0026rdquo; Mobile et \u0026ldquo;Input\u0026rdquo; Desktop Les \u0026ldquo;Common Gestures\u0026rdquo; Le \u0026ldquo;Scrollable List View\u0026rdquo; Les API \u0026ldquo;Touch actions\u0026rdquo; Exemples pratiques : \u0026ldquo;Swipe and Scroll by Element\u0026rdquo; \u0026ldquo;Swipe Screen\u0026rdquo; \u0026ldquo;Drag and Drop\u0026rdquo; \u0026ldquo;Toggle Buttons\u0026rdquo; \u0026ldquo;Handling Checkboxes and Radio Button\u0026rdquo; \u0026ldquo;Zooming Pinching\u0026rdquo; \u0026ldquo;Multi Touch Actions\u0026rdquo; \u0026ldquo;Mobile Orientation\u0026rdquo; Module 7 : Tests NG Introduction à TestNG (le quoi et pourquoi) Les différentes \u0026ldquo;Annotations\u0026rdquo; de TestNG L\u0026rsquo;exécution des tests avec le fichier testng.xml L\u0026rsquo;exécution de plusieurs fichiers en même temps La gestion de la priorité des tests (dependsOnMethods, etc.) L\u0026rsquo;utilisation des paramètres avec TestNG Les \u0026ldquo;DataProviders\u0026rdquo; Concepts avancés : \u0026ldquo;Grouping, Listeners\u0026rdquo; L\u0026rsquo;exécution des tests en parallèle avec TestNG Module 8 : Gradle Introduction à l\u0026rsquo;outil Gradle Les commandes du build essentials avec Gradle Module 9 : Framework d\u0026rsquo;automatisation de tests mobiles Introduction au framework de tests mobiles Les différentes couches nécessaires : La couche \u0026ldquo;Test Cases\u0026rdquo; La couche \u0026ldquo;DSL\u0026rdquo; La couche \u0026ldquo;Driver\u0026rdquo; La couche \u0026ldquo;SUT\u0026rdquo; Le pattern \u0026ldquo;Page Object Model\u0026rdquo; Exemple pratique Mini Projet (ExpandBank App): Conception Framework Utilisation du Pattern POM Bonnes Pratiques Module 10 : Le reporting Les caractéristiques d\u0026rsquo;un bon rapport de tests Les différentes options et outils de reporting Le reporting avec \u0026ldquo;Allure Report\u0026rdquo; Module 11 : L\u0026rsquo;intégration Continue avec CircleCI Introduction aux concepts d\u0026rsquo;intégration et livraison continues (pipelines CI/CD) Présentation du CircleCI Intégration du projet de tests dans CircleCI Module 12 : Le mot de la fin Synthèse Partage de ressources / docs / Articles sur le framework Appium Si vous avez des suggestions d\u0026rsquo;amélioration pour cette formation Appium n\u0026rsquo;hésitez pas à nous contacter !\n","permalink":"https://expandtesting.com/formations/tests-mobiles-appium/","tags":null,"title":"Formation Appium - Automatisation des tests mobiles"},{"categories":["Tests et Automatisation"],"contents":"Introduction Choisir le bon outil ou framework d\u0026rsquo;automatisation des tests pour un projet de développement logiciel est une décision cruciale. Il est donc important de prendre le temps et d’analyser les besoins spécifiques de votre projet, car le choix d’un framework en particulier pourrait être mieux adapté que les autres.\nCes dernières années, un nouveau framework open source est apparu dans le monde des frameworks d\u0026rsquo;automatisation des tests. C\u0026rsquo;est le framework Cypress qui se démarque des autres avec des fonctionnalités uniques et intéressantes.\nAprès plusieurs mois d\u0026rsquo;utilisation, j\u0026rsquo;ai décidé d\u0026rsquo;écrire quelques articles pour la communauté francophone afin de présenter les principaux concepts, les avantages mais aussi les limites de ce framework relativement nouveau.\nQu\u0026rsquo;est-ce que Cypress ? Cypress est un framework JavaScript d\u0026rsquo;automatisation des tests pour les applications Web modernes telles que Reactjs , Angularjs et Vuejs et aussi les applications Web classiques.\nCypress peut être utilisé pour les tests unitaires, de composants, d’intégration, d\u0026rsquo;API et notamment les tests d\u0026rsquo;acceptation (e2e).\nSur le site officiel, Cypress est présenté par la phrase suivante en anglais \u0026ldquo;Fast, easy and reliable testing for anything that runs in a browser.\u0026rdquo;.\nLe framework Cypress est un projet Open Source, mais il propose également une version payante (Dashboard service) avec des fonctionnalités supplémentaires pour les utilisateurs professionnels. La version payante donne accès à des fonctionnalités avancées de test et d\u0026rsquo;analyse, ainsi qu\u0026rsquo;à une assistance technique.\nEnfin, pourquoi ce nom Cypress ?\nCypress est en effet un arbre, ses feuilles sont toujours vertes durant toute l\u0026rsquo;année et ne tombent jamais. Avoir des tests verts, c\u0026rsquo;est ce que veulent les inventeurs de Cypress pour nos tests automatisés !\nLes concepts clés du framework Cypress Architecture Avec Cypress et contrairement à la plupart des autres outils (Selenium , WebdriverIO , Nightwatch.js) les tests sont exécutés directement dans le navigateur ce qui lui permet un contrôle total sur les différents éléments web et les événements de l’application sous test.\nGrâce à son proxy web, Cypress est capable de contrôler tout le trafic réseau de l’application sous test. Il est alors possible de contrôler les appels HTTP, d’attendre les réponses et même de mocker les réponses d’API utilisé par l’application sous tests si nécessaire\nSimplicité de prise en main Cypress utilise pour son fonctionnement un ensemble d\u0026rsquo;API et de frameworks très populaires tels que :\nMocha Chai Jquery Lodash Sinon Cela rend Cypress simple à utiliser et permet aux développeurs et aux ingénieurs QA de se concentrer principalement sur l\u0026rsquo;écriture de tests.\nCe framework autorise également l\u0026rsquo;accès à ses API internes via Cypress. Il est alors possible de profiter de plusieurs API:\nlodash Cypress._ jQuery Cypress.$ sinon Cypress.sinon Blob Cypress.Blob Buffer Cypress.Buffer La liste complète des API est disponible ici Cypress dispose également une interface utilisateur dans le navigateur qui vous permet de visualiser et de gérer vos tests (Run, Debug, ).\nDocumentation La documentation de Cypress fournit une aide complète sur l\u0026rsquo;utilisation de l\u0026rsquo;outil, y compris comment l\u0026rsquo;installer, comment écrire des tests et comment utiliser les différentes fonctionnalités offertes par l\u0026rsquo;outil. Vous pouvez trouver la documentation de Cypress en ligne sur le site web de Cypress Plugins Cypress a un bon nombre de plugins qui peuvent étendre ses fonctionnalités.\nVoici quelques exemples courants de plugins Cypress :\ncypress-grep cypress-file-upload cypress-axe cypress-mailosaur cypress-watch-and-reload Vous pouvez trouver plus de plugins ici Les limites du framework Cypress Comme tout outil, Cypress a quelques limites et inconvénients, mais heureusement il n\u0026rsquo;y en a pas beaucoup ! Vous pouvez trouver la liste complète des limitations sur le site de Cypress\nPas de support “Multi-tab” (multi-onglets) Étant donné que Cypress s\u0026rsquo;exécute dans le navigateur, il ne permet pas la prise en charge de plusieurs onglets lors de l\u0026rsquo;exécution de tests.\nUn seul langage de programmation Cypress ne supporte qu\u0026rsquo;un seul langage de programmation Javascript.\nTests iFrames Cypress.io lui-même utilise iFrames pour s\u0026rsquo;injecter dans le navigateur, donc tester les iFrames n\u0026rsquo;est pas très facile, mais ce n\u0026rsquo;est pas impossible. Vous pouvez trouver plus d\u0026rsquo;informations sur les tests iFrames ici Un exemple de test avec Cypress ? Une formation ? Si vous souhaitez en savoir plus sur Cypress et l\u0026rsquo;automatisation des tests d\u0026rsquo;acceptation avec Cypress, n\u0026rsquo;hésitez pas à consulter notre programme de formation Cypress Cet article vous a plu ❤️ ? N\u0026rsquo;hésitez pas à le partager pour que d\u0026rsquo;autres personnes puissent en profiter\n","permalink":"https://expandtesting.com/blog/introduction-au-framework-cypress/","tags":["Cypress","Outils","Testing"],"title":"Introduction au Framework Cypress"},{"categories":null,"contents":"La livraison continue est un processus de développement logiciel qui consiste à livrer de nouvelles versions d\u0026rsquo;un logiciel de manière régulière et fréquente.\nCela peut inclure la mise à jour de fonctionnalités existantes, la correction de bugs et la mise en place de nouvelles fonctionnalités. L\u0026rsquo;objectif de la livraison continue est de permettre aux équipes de développement de travailler de manière plus agile et de fournir des logiciels de qualité supérieure à leurs utilisateurs.\n","permalink":"https://expandtesting.com/glossaire/livraison-continue/","tags":null,"title":"Livraison continue"},{"categories":["Tests et Automatisation"],"contents":"Introduction Le design pattern Page Object Model (POM) est un des modèles de conception d\u0026rsquo;automatisation des tests les plus largement utilisés. Il est utilisé avec les principaux Frameworks d\u0026rsquo;automatisation des tests comme Selenium, WebdriverIO, Cypress, Nightwatch etc. La plupart des ingénieurs QA/SDET (Software Development Engineer in Test) ont à un moment donné utilisé une variante du design pattern page object model. Cependant, il est souvent très mal compris et mal implémenté, ce qui peut entraîner un code d\u0026rsquo;automatisation de test ultra fragile et difficile à maintenir.\nDans cet article, j\u0026rsquo;aborde les concepts clés du pattern page object model afin de le rendre plus clair et plus facile à comprendre pour les ingénieurs automaticiens de la communauté francophone.\nJ\u0026rsquo;aimerais commencer par deux citations, l\u0026rsquo;une de Simon Stewart le créateur de Selenium Webdriver et la seconde est une réflexion de Martin Fowler If you have WebDriver APIs in your test methods, You’re Doing It Wrong. \u0026ndash; Simon Stewart A page object wraps an HTML page, or fragment, with an application-specific API, allowing you to manipulate page elements without digging around in the HTML. A page object should also provide an interface that\u0026rsquo;s easy to program to and hides the underlying widgetry in the window page. The page object should encapsulate the mechanics required to find and manipulate the data in the page itself. A good rule of thumb is to imagine changing the concrete page -in which case the page object interface shouldn\u0026rsquo;t change. \u0026ndash; Martin Fowler Le problème Lorsque vous écrivez des tests fonctionnels à l\u0026rsquo;aide de Selenium Webdriver (ou à l\u0026rsquo;aide d\u0026rsquo;un autre framework), la grosse partie du travail consiste à gérer des interactions avec l\u0026rsquo;interface utilisateur via l\u0026rsquo;API Webdriver. La plupart du temps c\u0026rsquo;est le scenario classique suivant :\nInitialisation du contexte Récupération des éléments web Interactions avec les éléments web (saisie d\u0026rsquo;un texte, clique sur un élément, récupération de texte, etc.) Vérification des résultats à travers différentes assertions Considérez l\u0026rsquo;exemple suivant (Un test de login très basique avec Selenium Webdriver en JavaScript):\nawait driver.get(\u0026quot;http://the-internet.herokuapp.com/login\u0026quot;); await driver.findElement({ id: \u0026quot;username\u0026quot; }).sendKeys(\u0026quot;tomsmith\u0026quot;); await driver.findElement({ id: \u0026quot;password\u0026quot; }).sendKeys(\u0026quot;SuperSecretPassword!\u0026quot;); await driver.findElement({ css: \u0026quot;button\u0026quot; }).click(); assert(await driver.findElement({ css: \u0026quot;.flash.success\u0026quot; }).isDisplayed()); Comme vous l\u0026rsquo;avez certainement constaté, ceci est un simple test avec des actions limitées :\nChargement de l\u0026rsquo;URL du login Saisie du login Saisie du mot de passe Clique sur le bouton login Vérification de l\u0026rsquo;affichage d’un message de succès Et même avec un test très simple comme celui-ci, la lisibilité est très réduite. Il y a plusieurs utilisations de l\u0026rsquo;API Webdriver qui obscurcit le but principal du test. Avec une simple analyse on peut identifier quelques limites et problèmes pour cette approche:\nIl n\u0026rsquo;y a pas de séparation claire entre les méthodes de test et les localisateurs de l\u0026rsquo;application (locators). Ils sont tous dans une seule méthode. Si l\u0026rsquo;application change ses identifiants ou sa structure graphique, les tests doivent changer également. Imaginez un scénario de plusieurs tests qui nécessitent l\u0026rsquo;utilisation de cette fonctionnalité de login. Le même code de connexion sera du coup répété encore et encore dans chaque test. Tout changement dans l\u0026rsquo;interface utilisateur signifie que tous les tests devront être modifiés également. Le code ci-dessus n\u0026rsquo;est pas très lisible, n’est pas facilement maintenable, la réutilisable est très limitée et laisse la porte ouverte pour la duplication de code (Se sont exactement les problèmes traités par les concepts du pattern Page Object Model). La solution la plus courante L\u0026rsquo;une des solutions courantes pour résoudre ce problème consiste à utiliser le pattern page object model, il y a d\u0026rsquo;autres patterns comme le Screenplay/Journey Pattern mais ce n\u0026rsquo;est pas le sujet de ce post, cela peut faire l\u0026rsquo;objet d\u0026rsquo;un nouvel article\nQu\u0026rsquo;est-ce que le pattern page object model ? Ce pattern est un modèle de conception très populaire dans le contexte de l\u0026rsquo;automatisation des tests UI pour améliorer la maintenance des tests et réduire la duplication de code. Il s\u0026rsquo;agit d\u0026rsquo;un modèle de langage neutre pour représenter une page complète ou une partie d\u0026rsquo;une page de manière orientée objet. Et nous les utilisons pour modéliser l\u0026rsquo;interface utilisateur de l\u0026rsquo;application.\nAvec ce pattern, les objets de la page exposent des méthodes qui reflètent les actions ou les éléments graphiques qu\u0026rsquo;un utilisateur peut faire et voir sur une page web. Il cache également les détails d\u0026rsquo;implémentation indiquant au navigateur comment manipuler les éléments de la page.\nEn bref, le pattern page object model encapsule les différents comportements d\u0026rsquo;une page.\nVos tests utilisent ensuite les méthodes exposées par cette classe (page object) chaque fois qu\u0026rsquo;ils ont besoin d\u0026rsquo;interagir avec l\u0026rsquo;interface utilisateur.\nL\u0026rsquo;avantage est que si l\u0026rsquo;interface utilisateur de la page change, les tests eux-mêmes n\u0026rsquo;ont pas besoin de changer, seul le code dans la page object doit changer. Par la suite, toutes les modifications pour prendre en charge cette nouvelle interface utilisateur se trouvent au même endroit (page object).\nUne image vaut mille mots Cette figure illustre les concepts du pattern page object model\nPage Object Model Pourquoi utiliser le pattern page object model ? Les principales raisons sont les suivantes :\nMaintenabilité Réduction ou élimination de la duplication de code Lisibilité des scripts Réutilisabilité La scalabilité Amélioration de l\u0026rsquo;organisation du code source Implémentation Nous allons procéder étape par étape pour la mise en œuvre de cette technique de page object model, ci-dessous les étapes nécessaires:\nConfiguration basique de Selenium Webdriver Analyse de l\u0026rsquo;application sous test (AUT*) Écriture de page objects Écriture de tests Pour être plus précis ce n\u0026rsquo;est pas exactement la méthode que j\u0026rsquo;utilise tous les jours, car je commence par l\u0026rsquo;écriture des tests ce qui me permet de justifier chaque variable, chaque ligne de code et m\u0026rsquo;aider à faire du clean code. Mais c\u0026rsquo;est un sujet que je n\u0026rsquo;aborderais pas ici pour garder le focus sur le pattern page object model.\nConfiguration basique de Selenium Webdriver Externaliser le code de la gestion du cycle de vie du driver (Webdrivier) dans une classe ou un script séparé (Separation of concerns) est une excellente idée que je recommande très fortement. Ici dans mon cas j\u0026rsquo;utile mochajs , j\u0026rsquo;ai mis le code de la gestion du cycle de vie du driver dans les hooks mocha beforeEach et afterEach. Le pattern Driver Factory est également utilisé pour la gestion de plusieurs types de navigateurs mais ce n\u0026rsquo;est pas l\u0026rsquo;objet de l\u0026rsquo;article.\nconst DriverFactory = require(\u0026quot;./driver-factory\u0026quot;); const driverFactory = new DriverFactory(); beforeEach(async function () { const testName = this.currentTest.fullTitle(); this.driver = await driverFactory.build(testName); }); afterEach(async function () { await driverFactory.quit(); }); Analyse de l\u0026rsquo;application sous test (AUT*) AUT*: Application Under Test\nDans cet article j\u0026rsquo;ai utilisé l\u0026rsquo;application the-internet et principalement la page login avec deux scenarios simples :\nCas passant:\nLogin avec les informations correctes Cas non-passant:\nEchec de login avec des informations incorrectes Après une petite analyse j\u0026rsquo;ai pu identifie que le message qu\u0026rsquo;indique le succès ou l\u0026rsquo;échec du login ne fait pas partie de la page login, ni de la page cible une fois la connexion est réussie secure page , j\u0026rsquo;ai donc décidé de se limiter à la page login, gérer le message dans cette même page et de n\u0026rsquo;est pas créer le model page object pour la page secure, c\u0026rsquo;est largement suffisant pour cet exemple.\nÉcriture de Page objects Page object Login (Classe LoginPage) Ceci est le code de la classe page object login (LoginPage):\nconst BasePage = require(\u0026quot;./BasePage\u0026quot;); const LOGIN_FORM = { id: \u0026quot;login\u0026quot; }; const USERNAME_INPUT = { id: \u0026quot;username\u0026quot; }; const PASSWORD_INPUT = { id: \u0026quot;password\u0026quot; }; const SUBMIT_BUTTON = { css: \u0026quot;button\u0026quot; }; const SUCCESS_MESSAGE = { css: \u0026quot;.flash.success\u0026quot; }; const FAILURE_MESSAGE = { css: \u0026quot;.flash.error\u0026quot; }; class LoginPage extends BasePage { constructor(driver) { super(driver); } async load() { await this.visit(\u0026quot;/login\u0026quot;); if (!(await this.isDisplayed(LOGIN_FORM, 1000))) throw new Error(\u0026quot;Login form not loaded\u0026quot;); } async authenticate(username, password) { await this.type(USERNAME_INPUT, username); await this.type(PASSWORD_INPUT, password); await this.click(SUBMIT_BUTTON); } successMessagePresent() { return this.isDisplayed(SUCCESS_MESSAGE, 1000); } failureMessagePresent() { return this.isDisplayed(FAILURE_MESSAGE, 1000); } } module.exports = LoginPage; Base page object (Classe BasePage) const Until = require(\u0026quot;selenium-webdriver\u0026quot;).until; const config = require(\u0026quot;../configs/the-internet.config\u0026quot;); class BasePage { constructor(driver) { this.driver = driver; } async visit(url) { if (url.startsWith(\u0026quot;http\u0026quot;)) { await this.driver.get(url); } else { await this.driver.get(config.baseUrl + url); } } find(locator) { return this.driver.findElement(locator); } async click(locator) { await this.find(locator).click(); } async type(locator, inputText) { await this.find(locator).sendKeys(inputText); } async isDisplayed(locator, timeout) { if (timeout) { await this.driver.wait(Until.elementLocated(locator), timeout); await this.driver.wait( Until.elementIsVisible(this.find(locator)), timeout ); return true; } else { try { return await this.find(locator).isDisplayed(); } catch (error) { return false; } } } } module.exports = BasePage; Écriture de tests Maintenant nous avons tous les éléments nécessaires pour écrire les cas de tests. Ci-dessous le code nécessaire pour tester les deux scenarios de login, le cas passant et le cas non-passant\nrequire(\u0026quot;../support/mocha-hooks\u0026quot;); const assert = require(\u0026quot;assert\u0026quot;); const LoginPage = require(\u0026quot;../page-objects/login.page\u0026quot;); describe(\u0026quot;Verify Login\u0026quot;, function () { let login; beforeEach(async function () { login = new LoginPage(this.driver); await login.load(); }); it(\u0026quot;should be able to login with valid credentials\u0026quot;, async function () { await login.authenticate(\u0026quot;tomsmith\u0026quot;, \u0026quot;SuperSecretPassword!\u0026quot;); assert( await login.successMessagePresent(), \u0026quot;Success message not displayed\u0026quot; ); }); it(\u0026quot;should not be able to login with invalid credentials\u0026quot;, async function () { await login.authenticate(\u0026quot;invalid\u0026quot;, \u0026quot;invalid\u0026quot;); assert( await login.failureMessagePresent(), \u0026quot;Failure message not displayed\u0026quot; ); }); }); Comme vous l\u0026rsquo;avez certainement constaté, on n\u0026rsquo;utilise plus l\u0026rsquo;API Webdriver, On utilise plutôt les méthodes exposées par la classe page object login. Le code est maintenant beaucoup plus clair et nous avons plus de flexibilité pour réutiliser nos objets.\nBonnes pratiques Bien que la flexibilité soit présente, il y a quelques règles de base que vous devez respecter pour maintenir votre code :\nLe model page object n\u0026rsquo;a pas besoin d\u0026rsquo;être une page HTML entière, il peut aussi être un composant (C\u0026rsquo;est le cas notamment pour les applications modernes avec les framework React, Angular, etc.) Le model page object expose uniquement les méthodes qu\u0026rsquo;un utilisateur final utiliserait pour interagir avec la page, les méthodes comme readTxtFile(), connectToDataBase(), executeSQL(), etc. ne devrait pas être exposées au script de test. Ne créez pas tous les objets de page en même temps, ne faites que ce dont vous avez besoin à ce moment donné. Vous pouvez passer des jours (et parfois des semaines) à essayer de créer des pages objects pour l\u0026rsquo;ensemble de votre application et ce serait une perte de temps. Vos page objects augmenteront lorsque de nouvelles exigences arriveront, ce qui nécessitera de nouveaux scripts de test. Les assertions n\u0026rsquo;appartiennent pas aux page objects, elles appartiennent aux scripts de test. Les methodes de la page objects ne décident pas si un test passe ou échoue. Une exception à la règle ci-dessus est qu\u0026rsquo;il doit y avoir une seule vérification dans l\u0026rsquo;objet page et c\u0026rsquo;est pour vérifier que la page et tous les éléments importants de la page ont été chargés correctement. Cette vérification doit être effectuée lors de l\u0026rsquo;instanciation de l\u0026rsquo;objet de page. Conclusion En utilisant le pattern Page Object Model, vos tests deviennent plus concis et lisibles. Vos localisateurs d\u0026rsquo;éléments web sont centralisés, ce qui facilite énormément la maintenance et la scalabilité de votre framework. Les changements de l\u0026rsquo;interface utilisateur n\u0026rsquo;affectent que les page objects et non les scripts de test.\nSi vous avez aimé cet article, n\u0026rsquo;hésitez pas à le partager !\n","permalink":"https://expandtesting.com/blog/design-pattern-page-object-model/","tags":["POM","Design Patterns","SOLID","POO"],"title":"Comprendre le pattern Page Object Model"},{"categories":["Divers"],"contents":"À quoi sert exactement cette page ? LinkedIn est une plateforme idéale pour trouver un emploi, des collaborateurs ou des clients et développer votre activité.\nMais LinkedIn est aussi une plateforme incontournable pour acquérir de nouvelles compétences dans plusieurs domaines, notamment l\u0026rsquo;informatique.\nPlusieurs experts sont actifs dans ce réseau et partagent de nombreuses informations et ressources utiles :\nArticles Bonnes pratiques Recommandations Outils etc En revanche, trouver les liens vers les différentes ressources (posts, articles, etc.) n\u0026rsquo;est pas une tâche simple pour tout le monde. LinkedIn propose déjà une fonctionnalité pour enregistrer les liens, mais aucun moyen de partager ces liens avec d\u0026rsquo;autres personnes.\nJ\u0026rsquo;ai donc créé cette page pour répertorier les liens vers quelques ressources que je trouve intéressantes et utiles.\nJe vais d\u0026rsquo;abord me concentrer sur les sujets suivants :\nDéveloppement Testing DevOps et CI/CD SEO Cette liste sera mise à jour au fur et à mesure, pour l\u0026rsquo;instant je vais juste tester cette idée\nDéveloppement TDD (Test-Driven Development) Ressource Langue Auteur et lien Flaky tests EN Valentina Cupać CI/CD and TDD EN Valentina Cupać SEO (Search Engine Optimization) Ressource Langue Auteur et lien Technical SEO EN Mihir Naik Cet article vous a plu ❤️ ?\nN\u0026rsquo;hésitez pas à le partager pour que d\u0026rsquo;autres personnes puissent en profiter\n","permalink":"https://expandtesting.com/blog/apprendre-avec-publications-linkedin/","tags":["LinkedIn","Learning","Publications","Posts","Articles"],"title":"Apprendre avec les publications LinkedIn"},{"categories":["Tests et Automatisation"],"contents":" Introduction Ces dernières années, l\u0026rsquo;architecture des microservices est devenue de plus en plus populaire. Elle est largement adoptée par plusieurs entreprises.\nAvec une telle architecture et lorsqu\u0026rsquo;elle est réalisée correctement, elle offre plusieurs avantages:\nScalabilité Hétérogénéité technologique Réutilisabilité Résilience Maintenabilité En revanche, dans le monde des microservices, la difficulté des tests d\u0026rsquo;intégration est un enjeu majeur !\nPrenons un exemple simple d\u0026rsquo;une architecture composée de 10 microservices. Chaque service est géré par une équipe indépendante.\nCe scénario nous amène à nous poser les questions suivantes :\nComment tester les interactions entre les différents microservices ? Comment assurer la compatibilité des versions entre les microservices ? Comment gérer la synchronisation entre les différentes équipes ? L\u0026rsquo;approche classique pour tester cette architecture consiste à déployer les microservices dans des environnements de test séparés, puis à exécuter des tests automatisés de bout en bout.\nEt pour mettre en œuvre cette stratégie, certains prérequis sont nécessaires :\nSynchronisation entre les différentes équipes Préparation des jeux de données Préparation de l\u0026rsquo;infrastructure Sans surprise, l\u0026rsquo;efficacité de cette approche est généralement faible, on se retrouve avec :\nDes tests de bout en bout fragiles Une boucle de feedback lente Un coût d\u0026rsquo;infrastructure élevé Une augmentation du temps de test Un travail supplémentaire de synchronisation Cette approche de test est généralement plus adaptée aux architectures monolithiques mais pas aux microservices.\nExiste-t-il d\u0026rsquo;autres approches de test plus efficaces ?\nLa réponse est oui, une stratégie de tests de contrats (Contract Testing) pourrait être une solution plus fiable et plus efficace à ce véritable challenge des tests d\u0026rsquo;intégration !\nLes tests de contrats (Contract testing) Qu\u0026rsquo;est-ce que c\u0026rsquo;est les tests de contrats ? Les tests de contrats (Contract testing en anglais) est une technique de tests d\u0026rsquo;intégration inter-services.\nCette technique est généralement utilisée dans les architectures microservices. Elle permet de tester les points d\u0026rsquo;intégration en isolant chaque microservice et en vérifiant si les requêtes et les réponses HTTP transmises par le microservice sont conformes à une compréhension partagée et documentée dans un contrat.\nDe cette manière, les tests de contrats garantissent que les microservices peuvent communiquer entre eux.\nTerminologies Pour avoir une compréhension approfondie des tests contractuels, il est important de connaître les terminologies suivantes :\nConsommateur (Consumer) Le consommateur c\u0026rsquo;est l’application ou service (celui qui appelle l\u0026rsquo;API provider) qui utilise des fonctionnalités ou des données exposées par une autre application ou un autre service\nFournisseur (Provider) Le fournisseur c\u0026rsquo;est l\u0026rsquo;application qui fournit (expose des services http) des fonctionnalités ou des données pour une autre application ou un autre service\nContrat Un contrat est une forme documentée de compréhension partagée entre un consommateur et un fournisseur.\nLes différentes approches de tests de contrats Les trois approches les plus courantes sont celles utilisées par le projet PACT (Consumer-driven, provider-driven et Bidirectional) mais le principe reste valable avec d\u0026rsquo;autres outils ou technologies\nConsumer-driven contract testing (CDCT) Avec cette approche, chaque consommateur définit ses attentes (requêtes, réponses, messages) vis-à-vis d\u0026rsquo;un fournisseur Le contrat est donc généré par le consommateur et transmis au fournisseur Le fournisseur doit être en mesure de répondre à l\u0026rsquo;ensemble des attentes exprimées par le consommateur\nQuand faire du consumer-driven ?\nNombre limité de consommateurs Communication fluide entre les équipes Ex: Backend for Frontend Provider-driven contract testing (PDCT) Avec cette approche c’est le fournisseur qui s’occupe de la définition des différentes interactions (requêtes, réponses, messages). Le consommateur doit donc respecter les spécifications fournies par le fournisseur. Un contrat axé sur le fournisseur ressemble beaucoup à une documentation technique.\nQuand faire du provider-driven ?\nConsumers inconnus Nombre important de consommateurs Communication difficile entre les équipes Bidirectional contract testing (BDCT) Avec cette approche:\nLe fournisseur génère sa propre version du contrat Le consommateur génère sa propre version du contrat Une entité tierce s\u0026rsquo;occupe de la validation et la vérification des éventuels problèmes d\u0026rsquo;intégration A titre d’exemple la plateforme Pactflow dispose d\u0026rsquo;une fonctionnalité payante de Bidirectional contract testing\nLes outils de tests de contrats L’outil (Open source) le plus utilisé pour le contract testing c’est l’outil Pact PACT est un écosystème pour faire des tests contractuels, il est composé de plusieurs éléments:\nUne spécification Ensemble d\u0026rsquo;API: Dotnet , JavaScript , Java , Python , Php , Go , etc Pact-Broker: https://github.com/pact-foundation/pact_broker Il existe aussi d\u0026rsquo;autres outils comme:\nSpring Cloud Contract (Uniquement pour Java) … Notes importantes Un contrat NE REMPLACE PAS une bonne communication entre les équipes ! Le Contract Testing NE REMPLACE PAS les tests fonctionnels Le Contract Testing n’est pas recommandé pour les API Publiques L\u0026rsquo;utilisation du CI/CD est nécessaire pour accélérer / maîtriser le workflow global Ça vous intéresse ? Voulez-vous en savoir plus sur les tests de contrats ?\nLes slides JFTL La formation d’ automatisation des tests de contrats avec Pact Un BBL ? N\u0026rsquo;hésitez pas à me contacter Cet article vous a plu ❤️ ? N\u0026rsquo;hésitez pas à le partager pour que d\u0026rsquo;autres personnes puissent en profiter\n","permalink":"https://expandtesting.com/blog/tests-de-contrats/","tags":["Testing","Contract Testing","PACT"],"title":"Introduction aux tests de contrats"},{"categories":null,"contents":"Description Aujourd’hui les architectures microservices sont de plus en plus répandues.\nEn revanche une des grosses problématiques avec l\u0026rsquo;architecture distribuée à base de microservices est les tests d\u0026rsquo;intégration inter-services.\nLa question principale est de savoir comment assurer les différentes interactions (api rest, messages d\u0026rsquo;événements) entre les différents services qui composent une architecture distribuée ?\nUne stratégie de tests de contrats (Consumer-Driven Contract Testing / Directional Contract Testing) pourrait être une solution fiable et efficace à ce véritable défi des tests d\u0026rsquo;intégration inter-services ! Et pour mettre cette stratégie de tests de contrats en œuvre, le projet PACT.io (Open source) a créé une suite d\u0026rsquo;outils qui simplifie considérablement l\u0026rsquo;adoption des tests de contrats.\nCette formation Pact vous permettra d\u0026rsquo;acquérir et de maîtriser les concepts clés de l\u0026rsquo;automatisation des tests de contrats avec le framework Pact.io\nObjectifs pédagogiques À l\u0026rsquo;issue de cette formation d\u0026rsquo;automatisation des tests de contrats avec Pact, le participant sera en mesure de :\nComprendre les concepts fondamentaux des tests de contrats Concevoir des tests de contrats automatisés avec Pact (Consumer et Provider) Comprendre comment intégrer les tests de contrats avec Pact dans une chaîne de livraison continue Public concerné Testeurs ou développeurs désirant se former aux techniques d\u0026rsquo;automatisation des tests de contrats avec Pact QA Managers, Lead QA ou chef de projet tests logiciels Prérequis Connaissances de base en JavaScript Connaissances de base en tests fonctionnels Connaissances de base en tests d\u0026rsquo;API (Rest) Programme de la formation Le programme de cette formation est composé de plusieurs modules allant des notions de base aux notions avancées\nModule 1 : Introduction aux tests de contrats (Contract Testing) La différence entre architecture monolithique et microservices Les Problèmes avec les tests d\u0026rsquo;intégration traditionnels Que ce que c\u0026rsquo;est les tests de contrats ? Le principe de fonctionnement de tests de contrats Avantages des tests contractuels Les tests de contrats avec Pact Les cas où les tests de contrats ne sont pas applicables Présentation du projet PACT (pact.io) Module 2 : Les tests de contrats côté consommateur (Consumer) Définition du terme consommateur (Consumer) Création du projet consumer(Nodejs) Présentation et installation de la bibliothèque Pact-js Spécification et implémentation de tests de contrats avec Pact-js Exécution des tests d\u0026rsquo;intégration avec Pact et génération du fichier contrat. Explication du contenu du fichier contrat Synthèse des différents étapes d\u0026rsquo;implémentation Module 3 : Les tests de contrats côté fournisseur (Provider) Définition du terme fournisseur (Provider) Création du projet provider (nodejs) Implémentation des tests de vérification de contrats avec Pact-js Exécution des tests provider et vérification/validation du fichier contrat. Synthèse des différents étapes d\u0026rsquo;implémentation Module 4 : Pact-broker Introduction à l\u0026rsquo;utilité du pact-broker Présentation de l\u0026rsquo;interface graphique du serveur pact-borker Implémentation de la publication du contrat dans le projet consumer Publication du contrat et vérification du résultat sur l\u0026rsquo;interface graphique Implémentation de la récupération de contrat dans le projet provider. Récupération et validation de contact Synthèse des différents étapes d\u0026rsquo;implémentation et d\u0026rsquo;utilisation de l\u0026rsquo;outil pact-broker Module 5 : Intégration des tests de contrats dans une chaîne CI/CD Présentation de l\u0026rsquo;outil pact-cli Intégration du pipeline du projet consumer dans GitHub Actions Intégration du pipeline du projet provider dans GitHub Actions Validation de la chaîne complète de tests de contrats Module 6: Concepts avancés Bonnes pratiques Comprendre le concept “pending test” Comment éviter les boucles infinies sur la validation de contacts Module 7 : Le mot de la fin Synthèse Partage de ressources / docs / Articles concernant les tests de contrats ","permalink":"https://expandtesting.com/formations/tests-contrats-pact/","tags":null,"title":"Formation Pact - Automatisation des tests de contrats"},{"categories":null,"contents":"Definition Un test unitaire est un test qui permet de vérifier et valider le comportement d\u0026rsquo;une unité en isolation.\nLa définition de l\u0026rsquo;unité est une source constante de confusion dans la communauté des développeurs, mais aussi dans les entreprises.\nIl ya deux écoles:\nUne école qui considère l\u0026rsquo;unité comme une classe (notamment dans le contexte de la programmation orientée objet) Une école qui considère l\u0026rsquo;unité comme une unité fonctionnelle et peut donc correspondre à plusieurs classes. Le test peut traverser plusieurs classes. Quelle que soit la définition de l\u0026rsquo;unité, Un bon test unitaire doit respecter soigneusement les critères FIRST:\nFast: il doit être rapide, on peut l\u0026rsquo;exécuter à tout moment Isolated: il doit être isolé, indépendant de tous les autres tests et on peut l\u0026rsquo;exécuter sans respecter aucun ordre. Généralement une seule cause doit être à l\u0026rsquo;origine de son échec et non pas plusieurs. Repeatable: il doit être déterministe. Si le test est exécuté plusieurs fois avec les mêmes données d\u0026rsquo;entrée, le résultat ne devrait jamais changer. Self validating: le test doit faire une auto-validation par lui-même. cela se fait normalement à l\u0026rsquo;aide d\u0026rsquo;assertions du framework de tests Timely: il doit être écrit juste avant le code de production (système sous tests) qui fait passer le test. C\u0026rsquo;est en appliquant la méthode TDD (Test Driven Development). Un bon test doit respecter le modèle 3A (Arrange/Act/Assert):\nArrange: correspond à l\u0026rsquo;etape de l\u0026rsquo;initialisation du contexte du test (état initial du test) Act: correspond à l\u0026rsquo;etape de d\u0026rsquo;appel de la fonctionnalité à tester Assert: correspond à l\u0026rsquo;etape de la vérification du résultat du test Il est également possible d\u0026rsquo;utiliser le modèle GWT (Given-When-Then):\nGiven: correspond à l\u0026rsquo;etape de l\u0026rsquo;initialisation du contexte du test (état initial du test) When: correspond à l\u0026rsquo;etape de d\u0026rsquo;appel de la fonctionnalité à tester Then: correspond à l\u0026rsquo;etape de la vérification du résultat du test ","permalink":"https://expandtesting.com/glossaire/test-unitaire/","tags":null,"title":"Test Unitaire"},{"categories":null,"contents":"NOUS SOMMES RAVIS DE VOUS COMPTER PARMI NOUS.\nMerci d\u0026rsquo;avoir souscrit à nos news ! Nous espérons que vous les apprécierez et restons à votre écoute pour toute suggestion.\n","permalink":"https://expandtesting.com/confirmation-abonnement/","tags":null,"title":"Merci pour votre abonnement"},{"categories":null,"contents":" Frameworks de tests automatisés (Web, Api, Microservices, Mobile) Virtualisation des services externes Tests SEO (On-Page) Contract testing (Pact) Frameworks ATDD/BDD Stratégie d\u0026rsquo;automatisation des tests Proof of concept ","permalink":"https://expandtesting.com/services/tests-logiciels/","tags":null,"title":"Tests logiciels"},{"categories":null,"contents":"À propos de l\u0026rsquo;événement 12 \u0026amp; 13 juin 2023\nLe grand rassemblement des professionnels du test logiciel et de la qualité des systèmes d’information en France Cet événement a su s‘imposer au fil des années comme le rendez-vous fédérateur de la communauté française des tests logiciels. En effet, avec plus de 1 200 participants, 40 sponsors et 16 conférences thématiques mettant à l’honneur les témoignages d\u0026rsquo;experts du domaine, la JFTL est aujourd’hui un lieu d’échanges privilégié de l’ensemble des acteurs de ce marché, qui peuvent à cette occasion, rencontrer les experts les plus reconnus du secteur et échanger leurs expériences entre professionnels.\nPlus d\u0026rsquo;infos : https://www.cftl.fr/JFTL/accueil/ ","permalink":"https://expandtesting.com/evenements/jftl-edition-15/","tags":null,"title":"15ème édition de la Journée Française des Tests Logiciels"},{"categories":null,"contents":" Description Cypress est un framework JavaScript d\u0026rsquo;automatisation des tests d\u0026rsquo;acceptation conçu pour automatiser les tests d\u0026rsquo;applications web développées avec les frameworks modernes tels que Reactjs , Angularjs et Vuejs , mais il permet également de tester les applications web développées avec les technologies standards telles que HTML5, CSS et JavaScript.\nCypress permet d\u0026rsquo;automatiser plusieurs types de tests:\nLes tests de composants Les tests d\u0026rsquo;intégration Les tests d\u0026rsquo;API (Rest) Les tests d\u0026rsquo;acceptation / fonctionnels Le framework Cypress se démarque des autres outils et frameworks d\u0026rsquo;automatisation grâce à son architecture unique !\nAvec Cypress et contrairement à la plupart des autres outils ( Selenium , WebdriverIO , Nightwatch.js ) les tests sont exécutés directement dans le navigateur ce qui lui permet un contrôle total sur les différents éléments web de l\u0026rsquo;application sous test.\nCypress utilise un proxy web qui lui rend capable de contrôler tout le trafic réseau de l\u0026rsquo;application sous test. Il est donc capable de contrôler les appels HTTP, d\u0026rsquo;attendre les réponses et même de virtualiser les dépendances externes utilisées par l\u0026rsquo;application sous test si nécessaire.\nCypress utilise plusieurs API et frameworks open source et populaires tels que Mocha , Chai , Jquery , Lodash et dispose d\u0026rsquo;une interface graphique très utile pendant le développement et le débogage.\nCette formation Cypress vous permettra d\u0026rsquo;acquérir et de maîtriser les concepts clés de l\u0026rsquo;automatisation des tests fonctionnels avec le framework Cypress.\nObjectifs pédagogiques À l\u0026rsquo;issue de cette formation d\u0026rsquo;automatisation des tests avec Cypress, le participant sera en mesure de :\nComprendre l\u0026rsquo;architecture de l\u0026rsquo;outil Open Source Cypress Apprendre à utiliser les fonctionnalités les plus intéressantes de Cypress Concevoir des tests automatisés (Web et API) avec Cypress Comprendre comment intégrer les tests d\u0026rsquo;acceptation avec cypress dans une chaîne de livraison continue Public concerné Testeurs ou développeurs désirant se former aux techniques d\u0026rsquo;automatisation des tests avec cypress QA Managers, QA Lead Prérequis Connaissances de base en JavaScript Connaissances de base en tests fonctionnels ✅ Vous pouvez également suivre notre formation sur les fondamentaux de JavaScript Programme de la formation Le programme de cette formation est composé de plusieurs modules allant des notions de base aux notions avancées\nModule 1 : Introduction au Framework Cypress Le projet Cypress ? Architecture de Cypress La différence entre Cypress et Selenium Le principe de fonctionnement de Cypress Les fonctionnalités principales Exécution d\u0026rsquo;un exemple de code et explication du Test Runner (Cypress Runner) et du fonctionnement de cypress en arrière-plan Module 2 : Installation et configuration Conditions préalables (IDE: Vscode / Javascript) Mocha et Chai Installation de Cypress Création d\u0026rsquo;un projet Fichier package.json Fichier de configuration cypress.json (version \u0026lt; Cypress V10) Fichier de configuration cypress.config.js (version \u0026gt;= Cypress V10) La structure des dossiers (fixtures, e2e, support, screenshots, …) Module 3 : Interaction avec les WebElements Les terminologies DOM La structure d\u0026rsquo;un scénario de test automatisé (Principe AAA) Les différents types de localisateurs Web Un premier exemple avec Cypress Configuration de l’URL de base (baseUrl) Identification et recherche d\u0026rsquo;éléments Web L\u0026rsquo;attente implicite, pause et débogage Enregistrement de l’Objet de la commande (yielded subjects) La commande invoke Les cases à cocher et les boutons radio Listes et listes déroulantes Les tableaux Popups et infobulles Les fenêtres filles Manipulation des iframes Les assertions de Cypress Les assertions enchaînés Manipulation des Shadow DOM Module 4 : Étude approfondie des commandes Cypress et sa nature asynchrone Comprendre les commandes get et find Saisir le texte pour les validations à l\u0026rsquo;aide de la commande de texte Cypress Comprendre la différence entre les méthodes Jquery et les commandes Cypress Gérer les promesses asynchrones avec Cypress Manipulation des éléments invisibles dans Cypress Module 5 : Les concepts essentiels de Cypress Exécution de tests en mode Headless Attentes implicites, pause, débogage Validation du nombre d\u0026rsquo;éléments Web sur la page Les log de Cypress Actualisation (refresh) et recharge (reload) du navigateur Variables et alias Captures d\u0026rsquo;écran Vidéos Module 6 : Les concepts avancés de Cypress Les variables d\u0026rsquo;environnement Utilisation des fixtures (fichiers de données) Commandes personnalisées Utilisation des Hooks Utilisation du pattern Page Object Model avec Cypress Mocks et Stub Les tests d\u0026rsquo;API avec Cypress Techniques de tentatives (Retries / Gestion des tests flaky) Reporters Cypress (Spec, Mocha Awesome, Allure) Exécution des tests sur différents navigateurs (Running different browsers / Cross Browser Testing) Les Tests de bout en bout (e2e) avec Cypress Exécution des tests Cypress dans un environnement CI Présentation de CircleCI / Github-Actions Exécution des tests Cypress avec CircleCI Exécution des tests Cypress avec GitHub-Actions Module 7 : Le mot de la fin Synthèse Partage de ressources / docs / Articles sur le framework Cypress Nous avons créé la plateforme practice pour soutenir cette formation.\nCette plateforme offre aux apprenants une expérience pratique. Elle contient des exemples de démonstration pour différents challenges de tests automatisés, incluant des applications React et des API REST.\nLa plateforme practice En plus de cela, notre plateforme propose également un outil d\u0026rsquo;aide à l\u0026rsquo;apprentissage des sélecteurs CSS \u0026amp; Xpath selector . Cet outil permet aux apprenants de perfectionner leurs compétences en sélecteurs CSS \u0026amp; Xpath nécessaires pour l\u0026rsquo;identification des éléments web.\nXpath and Css Selector Tester Si vous avez des suggestions d\u0026rsquo;amélioration pour cette formation cypress n\u0026rsquo;hésitez pas à nous contacter !\n","permalink":"https://expandtesting.com/formations/tests-acceptation-cypress/","tags":null,"title":"Formation Cypress - Automatisation des tests d'acceptation"},{"categories":null,"contents":" Test et qualité des applications Automatisation des tests web ( Cypress , WebdriverIO, Selenium) Automatisation des tests mobiles ( Appium ) Contract testing avec l\u0026rsquo;outil Pact Pipelines CI/CD (CircleCI, Github-Actions) Pratiques ATDD/BDD (Example Mapping) Frameworks ATDD/BDD ( Specflow / Cucumber ) Outils de gestion des tests manuels et automatisés ( Xray ) ","permalink":"https://expandtesting.com/services/formations/","tags":null,"title":"Formations"},{"categories":null,"contents":" Audit de maturité des tests Amélioration des processus de tests logiciels Conseil en Stratégie d\u0026rsquo;automatisation des tests ","permalink":"https://expandtesting.com/services/conseils-audits/","tags":null,"title":"Conseils et audits"},{"categories":["Programmation"],"contents":"Introduction Aujourd\u0026rsquo;hui, il est clair que l\u0026rsquo;écosystème JavaScript est incontournable pour le développement d\u0026rsquo;applications web et mobiles modernes (frontend et backend). La plupart des frameworks frontend modernes sont en javaScript tels que ReactJs , Angular , VueJs etc\u0026hellip; C’est aussi le même constat pour les frameworks, outils et lib d\u0026rsquo;automatisation de tests. Les frameworks comme PlayWright , WebdriverIO , Cypress , NightwatchJs sont tous en JavaScript.\nAvant d\u0026rsquo;entrer dans le vif du sujet, il est important de rappeler que JavaScript est un langage mono-thread et synchrone.\nUn seul thread signifie que le code JavaScript n\u0026rsquo;a qu\u0026rsquo;un seul thread principal pour exécuter toutes les instructions (seul et unique thread pour toute son exécution)\nLe thread est non bloquant lorsque le code doit effectuer une tâche asynchrone (une tâche qui ne peut pas renvoyer le résultat immédiatement et prend un certain temps pour revenir, comme un événement d\u0026rsquo;E/S), le thread principal suspendra la tâche, puis exécutera le callback correspondant selon certaines règles lorsque la tâche asynchrone retourne le résultat.\nSi quelqu\u0026rsquo;un vous dit le contraire, je vous propose de lui demander de bien vouloir regarder cette vidéo de Philip Roberts pour mieux comprendre le fonctionnement de JavaScript et plus particulièrement l\u0026rsquo;event loop!\nCode synchrone vs code asynchrone Exemple de programme synchrone Examinons l\u0026rsquo;exemple suivant:\nconsole.log(\u0026quot;Before\u0026quot;); console.log(\u0026quot;Welcome\u0026quot;); console.log(\u0026quot;After\u0026quot;); Dans ce bloc, les lignes sont exécutées les unes après les autres. Pendant que chaque instruction est en cours de traitement, rien d\u0026rsquo;autre ne peut se produire. Tout le reste est bloqué jusqu\u0026rsquo;à la fin d\u0026rsquo;exécution de l\u0026rsquo;opération / instruction en cours. Cela est dû au fait que, JavaScript est ne dispose que d\u0026rsquo;un seul thread.\nBefore Welcome After Exemple de programme asynchrone Les fonctions JavaScript sont synchrone, les accès I/O sont asynchrones (accès fichiers, accès base de données, requêtes HTTP, \u0026hellip;). Prenons comme exemple la fonction \u0026ldquo;setTimeout(callback, timeout)\u0026rdquo; qui est une fonction asynchrone qui exécute une fonction donnée (callback) après un délai exprimé en millisecondes.\nExaminons l\u0026rsquo;exemple suivant:\nconsole.log(\u0026quot;Before\u0026quot;); setTimeout(() =\u0026gt; { console.log(\u0026quot;Reading a user from a database ...\u0026quot;); }, 2000); console.log(\u0026quot;After\u0026quot;); Dans ce bloc, la méthode setTimeout est exécutée de façon asynchrone sans bloquer le thread principal. On voit que la réponse de la méthode setTimeout (Reading a user from a database ...) arrive après 2 secondes d\u0026rsquo;attente sans bloquer le thread ni l\u0026rsquo;exécution des autres instructions\u0026hellip;\nBefore After Reading a user from a database ... Maintenant je vous invite à regarder cette vidéo sur ma chaîne YouTube pour en savoir plus sur la différence entre la programmation synchrone et asynchrone en JavaScript.\nVidéo [1/4] Synchrone vs Asynchrone Les callbacks \u0026amp; l\u0026rsquo;enfer des callbacks (Callback hell) Un callback ou fonction de rappel/retour est une fonction passée dans une autre fonction en tant qu\u0026rsquo;argument, qui est ensuite invoquée à l\u0026rsquo;intérieur de la fonction externe pour accomplir une tâche bien précise\nfunction sayHelloTo(msg, callback){ var message = \u0026quot;Hello, Welcome to \u0026quot; + msg; callback(message); } function displayWelcomeMsg(msg){ console.log(msg); } sayHelloTo(\u0026quot;ExpandTesting.com!\u0026quot;, displayWelcomeMsg); Hello, Welcome to ExpandTesting.com! Dans l\u0026rsquo;exemple ci-dessus, sayHelloTo est la fonction externe d\u0026rsquo;ordre supérieur, qui accepte deux arguments, le premier c\u0026rsquo;est le message et le second c\u0026rsquo;est le callback. La fonction displayWelcomeMsg est transmise en tant que fonction callback qui est ensuite invoquée à l\u0026rsquo;intérieur de la fonction sayHelloTo\nNous pouvons aussi transmettre des fonctions anonymes en tant que callback. L\u0026rsquo;appel ci-dessous à la fonction sayHelloTo aurait le même résultat que l\u0026rsquo;exemple ci-dessus:\nsayHelloTo(\u0026quot;ExpandTesting.com!\u0026quot;, function(msg){ console.log(msg); }); C\u0026rsquo;est aussi le même principe avec les fonctions fléchées\nsayHelloTo(\u0026quot;ExpandTesting.com!\u0026quot;, (msg) =\u0026gt; { console.log(msg); }); Prenons un exemple illustratif:\nSupposons que nous devons récupérer les messages de \u0026ldquo;commit\u0026rdquo; pour un repo github d\u0026rsquo;un utilisateur donné. Nous allons avoir une première méthode getUser qui va chercher l’utilisateur correspondant à un identifiant. Une fois l\u0026rsquo;utilisateur trouvé, il faut appeler la fonction asynchrone getRepos qui va renvoyer les repos de l\u0026rsquo;utilisateur, une fois les repos obtenus, il faut appeler la fonction asynchrone getCommits qui va récupérer les messages de \u0026ldquo;commit\u0026rdquo; pour un repo donné via les API Github.\nNous allons maintenant développer une première solution avec l\u0026rsquo;utilisation des callbacks.\nfunction getCommits(repoName, callback) { setTimeout(() =\u0026gt; { console.log(`Calling Github API for ${repoName}...`); callback([\u0026quot;commit 1\u0026quot;, \u0026quot;commit 2\u0026quot;]); }, 2000); } function getRepos(userName, callback) { setTimeout(() =\u0026gt; { console.log(`Calling Github API for ${userName}...`); callback([\u0026quot;repo1\u0026quot;, \u0026quot;repo2\u0026quot;]); }, 2000); } function getUser(id, callback) { setTimeout(() =\u0026gt; { console.log(\u0026quot;Reading a user from a database ...\u0026quot;); callback({ id: id, name: \u0026quot;tawfiknouri\u0026quot; }); }, 2000); } getUser(1, (user) =\u0026gt; { getRepos(user.name, (repos) =\u0026gt; { getCommits(repos[0], (commits) =\u0026gt; { console.log(commits) }) }) }); Reading a user from a database ... Calling Github API for tawfiknouri... Calling Github API for repo1... [ 'commit 1', 'commit 2' ] L\u0026rsquo;imbrication de plusieurs appels asynchrones en passant les callbacks en cas de succès et en cas d\u0026rsquo;erreur, sans parler des cas où il faut s\u0026rsquo;assurer que tous les appels à des fonctions asynchrones exécutées en parallèles soient terminés, devient très vite infernal on parle alors de callbacks hell.\nToutes les instructions de cette solution sont détaillées dans la vidéo suivante Vidéo [2/4] Les callbacks Promises Une promesse est un objet de type Promise qui permet de simplifier l\u0026rsquo;écriture des fonctions asynchrones. Un objet de type Promise est instancié en lui fournissant en argument la fonction asynchrone à exécuter qui prend elle-même en arguments la fonction callback à exécuter en cas de succès (resolve) et celle à exécuter en cas d\u0026rsquo;erreur (reject).\nVoici un exemple de déclaration et d\u0026rsquo;utilisation d\u0026rsquo;un objet Promise:\nconst p = new Promise((resolve, reject)=\u0026gt; { // kick off some async work setTimeout(() =\u0026gt; { const flag = true; if (flag === true) { resolve(\u0026quot;Time is up!\u0026quot;); } else { reject(\u0026quot;Oops!\u0026quot;); } }, 2000); }); p.then( (msg) =\u0026gt; {console.log(msg)}) .catch ((msg) =\u0026gt; {console.log(msg)}) .finally ( () =\u0026gt; { console.log(\u0026quot;Always called!\u0026quot;); }); Time is up! Always called! La méthode then() de l\u0026rsquo;objet promise p permet d\u0026rsquo;exploiter le résultat de la fonction asynchrone. La méthode catch() de l\u0026rsquo;objet promise p permet la gestion des erreurs qui peuvent survenir lors de l\u0026rsquo;exécution de la fonction asynchrone. La méthode finally() de l\u0026rsquo;objet promise p permet d\u0026rsquo;exécuter un traitement dès qu\u0026rsquo;une promesse est terminée, qu\u0026rsquo;elle soit tenue ou rejetée Repérons maintenant notre exemple initial et le redéveloppé en utilisant les Promises:\nfunction getCommits(repoName) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(`Calling Github API for ${repoName}...`); resolve([\u0026quot;commit 1\u0026quot;, \u0026quot;commit 2\u0026quot;]); }, 2000); }); } function getRepos(userName) { return new Promise((resolve, rject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(`Calling Github API for ${userName}...`); resolve([\u0026quot;repo1\u0026quot;, \u0026quot;repo2\u0026quot;]); }, 2000); }); } function getUser(id) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026quot;Reading a user from a database ...\u0026quot;); resolve({ id: id, name: \u0026quot;tawfiknouri\u0026quot; }); }, 2000); }); } getUser(1) .then((user) =\u0026gt; getRepos(user.name)) .then((repos) =\u0026gt; getCommits(repos[0])) .then((commits) =\u0026gt; { console.log(commits); }) .catch((err) =\u0026gt; { console.log(err); }) .finally(() =\u0026gt; { console.log(\u0026quot;Done!\u0026quot;); }); Reading a user from a database ... Calling Github API for tawfiknouri... Calling Github API for repo1... [ 'commit 1', 'commit 2' ] Done! Toutes les instructions de cette solution sont détaillées dans la vidéo suivante :\nVidéo [3/4] Les promises Async and Await ECMAScript 7 (ES7) a introduit deux nouveaux mots-clefs (async et await) permettant de simplifier davantage l\u0026rsquo;écriture de fonctions asynchrones en JavaScript pour qu\u0026rsquo;elles ressemblent aux fonctions synchrones.\nLa déclaration d\u0026rsquo;une fonction asynchrone doit être précédée de mot-clef async, tandis que l\u0026rsquo;appel à une fonction asynchrone est, quant à elle, précédée de mot-clef await.\nLe mot-clef async créera automatiquement une promesse qu\u0026rsquo;elle va résoudre avec le résultat du retour.\nLe mot-clef await attendra que la promesse soit résolue et qu\u0026rsquo;elle retourne un résultat, il ne peut être placé que dans une fonction elle-même asynchrone !\nRepérons maintenant notre exemple initial à l\u0026rsquo;aide de la syntaxe d\u0026rsquo;async/await:\nasync function displayCommits() { try { const user = await getUser(1); const repos = await getRepos(user.name); const commits = await getCommits(repos[0]); console.log(commits); } catch (error) { console.log(error); } finally { console.log(\u0026quot;Done!\u0026quot;); } } displayCommits(); Reading a user from a database ... Calling Github API for tawfiknouri... Calling Github API for repo1... [ 'commit 1', 'commit 2' ] Done! Le bloc try exécutera un code sensible qui peut lever des exceptions Le bloc catch sera utilisé chaque fois qu\u0026rsquo;une exception (du type pris) est levée dans le bloc try Le bloc finally est appelé dans chaque cas après les blocs try/catch. Toutes les instructions de cette solution sont détaillées dans la vidéo suivante :\nVidéo [4/4] La syntaxe Async / Await Si vous avez aimé cet article, n\u0026rsquo;hésitez pas à le partager ! J\u0026rsquo;espère que vous allez apprécier les vidéos, n\u0026rsquo;oubliez pas de vous abonner à ma chaîne YouTube , merci pour votre support !\n","permalink":"https://expandtesting.com/blog/javascript-asynchrone/","tags":["JavaScript","Testing"],"title":"Programmation asynchrone en JavaScript"},{"categories":["Tests et Automatisation"],"contents":"Introduction Dans un précédent article j\u0026rsquo;ai expliqué comment choisir la meilleure stratégie de localisation webdriver en fonction du contexte du projet.\nEn revanche il manquait des données statistiques Css Vs.Xpath pour réduire la propagation du bruit 😛\nEt justement pour trouver les données j\u0026rsquo;ai effectué plusieurs recherches sur internet … Malheureusement aucune source fiable, claire à l\u0026rsquo;exception d\u0026rsquo;un ancien benchmark de Dave Haeffner, mais les données ne sont pas à jour depuis des années !.\nJ\u0026rsquo;ai donc décidé de faire un benchmark pour mesurer la performance des sélecteurs Web Css et Xpath pour plusieurs navigateurs et sur plusieurs plateformes.\nPréparation du benchmark Comme tout benchmark la préparation du contexte est un élément essentiel pour obtenir de bons résultats.\nPour réaliser ce travail, je me suis servi de plusieurs idées provenant de l\u0026rsquo;ancien benchmark de Dave Haeffner notamment pour le choix des sélecteurs css/xpath et aussi pour la page web de test qui sera utilisée par ce benchmark.\nCette page à été développée par Dave pour réaliser son benchmark à l\u0026rsquo;époque, elle contient une structure HTML particulièrement intéressante (page large et profonde) pour faire des tests comparatifs css vs xpath sur plusieurs navigateurs …\nLe principe de ce benchmark est simple, une fois la page de test est chargée par le navigateur, on exécute la commande selenium await driver.findElement(locator) plusieurs fois avec plusieurs stratégies css, xpath et on mesure pour chaque stratégie le nombre d\u0026rsquo;opérations par seconde.\nEt pour obtenir les meilleurs mesures possible je me suis servi du benchmarkjs un outil de benchmarking en javascript très populaire et possède un algorithme qui calcul automatiquement le nombre des itérations nécessaires pour faire un test et exécute également des tests à vide pour assurer une certaine stabilité avant de lancer le benchmark.\nLa page sous test n\u0026rsquo;est qu\u0026rsquo;une version locale de la page disponible ici , elle est servie localement via le framework expressjs.\nUn dernier point important, le benchmark est exécuté sur des machines virtuelles similaires (configuration hardware similaire) sur la plateforme Github Actions.\nCette configuration nous permet d\u0026rsquo;éviter les effets de bord notamment la latence de la transmission des données via internet etc.\nLes localisateurs Css et Xpath Plusieurs localisateurs css, xpath on été utilisés (ce sont les même localisateurs de Dave), le choix est bien étudié, on retrouve des localisateurs simples (ID, class, etc.), mais aussi des localisateurs complexes pour traverser entièrement la page ….\nJe vous donne ici un exemple, mais attention il ne faut pas utiliser ce type de localisateurs dans vos projets c’est fragile, n\u0026rsquo;hésitez pas de regarder cet article pour savoir comment choisir la meilleure stratégie possible\nExemple localisateur CSS div#siblings \u0026gt; div:nth-of-type(1) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) \u0026gt; div:nth-of-type(3) La liste complete des localisateurs webdriver (stratégies) Option Description Locator 1 nested sibling traversal Locator 2 nested sibling traversal by class Locator 3 table header id_and_class Locator 4 table header id class and direct desc Locator 5 table header traversing Locator 6 table header traversing and direct desc Locator 7 table cell id and_class Locator 8 table cell id class and direct desc Locator 9 table cell traversing Locator 10 table cell traversing and direct desc Les résultats Chrome Chrome | Linux Rapport graphique\nCss Vs Xpath - Chrome - Linux Log benchmark-js\ncss =\u0026gt; nested_sibling_traversal x 139 ops/sec ±8.44% (72 runs sampled) xpath =\u0026gt; nested_sibling_traversal x 132 ops/sec ±1.78% (78 runs sampled) css =\u0026gt; nested_sibling_traversal_by_class x 153 ops/sec ±1.53% (80 runs sampled) xpath =\u0026gt; nested_sibling_traversal_by_class x 98.61 ops/sec ±1.58% (77 runs sampled) css =\u0026gt; table_header_id_and_class x 157 ops/sec ±1.49% (81 runs sampled) xpath =\u0026gt; table_header_id_and_class x 139 ops/sec ±1.47% (81 runs sampled) css =\u0026gt; table_header_id_class_and_direct_desc x 158 ops/sec ±1.19% (82 runs sampled) xpath =\u0026gt; table_header_id_class_and_direct_desc x 142 ops/sec ±1.26% (83 runs sampled) css =\u0026gt; table_header_traversing x 158 ops/sec ±1.41% (82 runs sampled) xpath =\u0026gt; table_header_traversing x 139 ops/sec ±1.51% (81 runs sampled) css =\u0026gt; table_header_traversing_and_direct_desc x 158 ops/sec ±1.36% (82 runs sampled) xpath =\u0026gt; table_header_traversing_and_direct_desc x 141 ops/sec ±1.17% (82 runs sampled) css =\u0026gt; table_cell_id_and_class x 159 ops/sec ±1.06% (83 runs sampled) xpath =\u0026gt; table_cell_id_and_class x 111 ops/sec ±1.56% (75 runs sampled) css =\u0026gt; table_cell_id_class_and_direct_desc x 159 ops/sec ±1.35% (81 runs sampled) xpath =\u0026gt; table_cell_id_class_and_direct_desc x 114 ops/sec ±1.62% (77 runs sampled) css =\u0026gt; table_cell_traversing x 162 ops/sec ±1.37% (82 runs sampled) xpath =\u0026gt; table_cell_traversing x 104 ops/sec ±1.87% (76 runs sampled) css =\u0026gt; table_cell_traversing_and_direct_desc x 161 ops/sec ±1.44% (77 runs sampled) xpath =\u0026gt; table_cell_traversing_and_direct_desc x 123 ops/sec ±1.78% (73 runs sampled) Chrome | Windows Rapport graphique Css Vs Xpath - Chrome - Windows Log benchmark-js css =\u0026gt; nested_sibling_traversal x 156 ops/sec ±2.04% (77 runs sampled) xpath =\u0026gt; nested_sibling_traversal x 144 ops/sec ±5.36% (75 runs sampled) css =\u0026gt; nested_sibling_traversal_by_class x 185 ops/sec ±1.55% (78 runs sampled) xpath =\u0026gt; nested_sibling_traversal_by_class x 103 ops/sec ±2.30% (74 runs sampled) css =\u0026gt; table_header_id_and_class x 192 ops/sec ±1.34% (80 runs sampled) xpath =\u0026gt; table_header_id_and_class x 155 ops/sec ±1.64% (72 runs sampled) css =\u0026gt; table_header_id_class_and_direct_desc x 175 ops/sec ±2.00% (81 runs sampled) xpath =\u0026gt; table_header_id_class_and_direct_desc x 156 ops/sec ±1.63% (79 runs sampled) css =\u0026gt; table_header_traversing x 181 ops/sec ±3.12% (76 runs sampled) xpath =\u0026gt; table_header_traversing x 148 ops/sec ±1.70% (76 runs sampled) css =\u0026gt; table_header_traversing_and_direct_desc x 180 ops/sec ±1.52% (79 runs sampled) xpath =\u0026gt; table_header_traversing_and_direct_desc x 154 ops/sec ±1.28% (79 runs sampled) css =\u0026gt; table_cell_id_and_class x 182 ops/sec ±1.18% (79 runs sampled) xpath =\u0026gt; table_cell_id_and_class x 123 ops/sec ±1.92% (72 runs sampled) css =\u0026gt; table_cell_id_class_and_direct_desc x 180 ops/sec ±1.50% (76 runs sampled) xpath =\u0026gt; table_cell_id_class_and_direct_desc x 118 ops/sec ±3.40% (72 runs sampled) css =\u0026gt; table_cell_traversing x 171 ops/sec ±1.94% (79 runs sampled) xpath =\u0026gt; table_cell_traversing x 116 ops/sec ±1.66% (77 runs sampled) css =\u0026gt; table_cell_traversing_and_direct_desc x 174 ops/sec ±2.15% (80 runs sampled) xpath =\u0026gt; table_cell_traversing_and_direct_desc x 136 ops/sec ±2.34% (79 runs sampled) Chrome | MacOS Rapport graphique Css Vs Xpath - Chrome - MacOs Log benchmark-js css =\u0026gt; nested_sibling_traversal x 174 ops/sec ±6.86% (68 runs sampled) xpath =\u0026gt; nested_sibling_traversal x 160 ops/sec ±1.35% (72 runs sampled) css =\u0026gt; nested_sibling_traversal_by_class x 192 ops/sec ±1.37% (73 runs sampled) xpath =\u0026gt; nested_sibling_traversal_by_class x 114 ops/sec ±2.57% (71 runs sampled) css =\u0026gt; table_header_id_and_class x 197 ops/sec ±0.78% (75 runs sampled) xpath =\u0026gt; table_header_id_and_class x 171 ops/sec ±1.00% (73 runs sampled) css =\u0026gt; table_header_id_class_and_direct_desc x 198 ops/sec ±1.19% (72 runs sampled) xpath =\u0026gt; table_header_id_class_and_direct_desc x 166 ops/sec ±1.37% (70 runs sampled) css =\u0026gt; table_header_traversing x 203 ops/sec ±0.77% (76 runs sampled) xpath =\u0026gt; table_header_traversing x 170 ops/sec ±1.31% (70 runs sampled) css =\u0026gt; table_header_traversing_and_direct_desc x 200 ops/sec ±0.69% (75 runs sampled) xpath =\u0026gt; table_header_traversing_and_direct_desc x 172 ops/sec ±1.23% (71 runs sampled) css =\u0026gt; table_cell_id_and_class x 202 ops/sec ±0.84% (74 runs sampled) xpath =\u0026gt; table_cell_id_and_class x 128 ops/sec ±1.46% (70 runs sampled) css =\u0026gt; table_cell_id_class_and_direct_desc x 206 ops/sec ±0.72% (75 runs sampled) xpath =\u0026gt; table_cell_id_class_and_direct_desc x 130 ops/sec ±1.32% (68 runs sampled) css =\u0026gt; table_cell_traversing x 204 ops/sec ±0.87% (77 runs sampled) xpath =\u0026gt; table_cell_traversing x 120 ops/sec ±1.84% (72 runs sampled) css =\u0026gt; table_cell_traversing_and_direct_desc x 205 ops/sec ±0.71% (77 runs sampled) xpath =\u0026gt; table_cell_traversing_and_direct_desc x 151 ops/sec ±1.41% (70 runs sampled) Firefox Firefox | Linux Rapport graphique Css Vs Xpath - FireFox - Linux Log benchmark-js css =\u0026gt; nested_sibling_traversal x 356 ops/sec ±4.82% (74 runs sampled) xpath =\u0026gt; nested_sibling_traversal x 347 ops/sec ±3.88% (78 runs sampled) css =\u0026gt; nested_sibling_traversal_by_class x 424 ops/sec ±3.74% (80 runs sampled) xpath =\u0026gt; nested_sibling_traversal_by_class x 144 ops/sec ±10.40% (78 runs sampled) css =\u0026gt; table_header_id_and_class x 460 ops/sec ±4.26% (79 runs sampled) xpath =\u0026gt; table_header_id_and_class x 403 ops/sec ±3.73% (80 runs sampled) css =\u0026gt; table_header_id_class_and_direct_desc x 474 ops/sec ±4.29% (82 runs sampled) xpath =\u0026gt; table_header_id_class_and_direct_desc x 431 ops/sec ±3.47% (80 runs sampled) css =\u0026gt; table_header_traversing x 481 ops/sec ±4.07% (79 runs sampled) xpath =\u0026gt; table_header_traversing x 396 ops/sec ±5.16% (81 runs sampled) css =\u0026gt; table_header_traversing_and_direct_desc x 470 ops/sec ±4.29% (80 runs sampled) xpath =\u0026gt; table_header_traversing_and_direct_desc x 411 ops/sec ±4.91% (77 runs sampled) css =\u0026gt; table_cell_id_and_class x 494 ops/sec ±1.59% (82 runs sampled) xpath =\u0026gt; table_cell_id_and_class x 300 ops/sec ±1.34% (84 runs sampled) css =\u0026gt; table_cell_id_class_and_direct_desc x 511 ops/sec ±1.36% (84 runs sampled) xpath =\u0026gt; table_cell_id_class_and_direct_desc x 312 ops/sec ±1.32% (85 runs sampled) css =\u0026gt; table_cell_traversing x 509 ops/sec ±1.46% (80 runs sampled) xpath =\u0026gt; table_cell_traversing x 290 ops/sec ±1.28% (83 runs sampled) css =\u0026gt; table_cell_traversing_and_direct_desc x 520 ops/sec ±1.43% (84 runs sampled) xpath =\u0026gt; table_cell_traversing_and_direct_desc x 420 ops/sec ±4.66% (83 runs sampled) Firefox | Windows Rapport graphique Css Vs Xpath - FireFox - Windows Log benchmark-js css =\u0026gt; nested_sibling_traversal x 350 ops/sec ±8.12% (72 runs sampled) xpath =\u0026gt; nested_sibling_traversal x 347 ops/sec ±3.56% (78 runs sampled) css =\u0026gt; nested_sibling_traversal_by_class x 437 ops/sec ±4.55% (78 runs sampled) xpath =\u0026gt; nested_sibling_traversal_by_class x 140 ops/sec ±2.69% (78 runs sampled) css =\u0026gt; table_header_id_and_class x 445 ops/sec ±4.22% (76 runs sampled) xpath =\u0026gt; table_header_id_and_class x 382 ops/sec ±3.40% (76 runs sampled) css =\u0026gt; table_header_id_class_and_direct_desc x 474 ops/sec ±4.42% (77 runs sampled) xpath =\u0026gt; table_header_id_class_and_direct_desc x 420 ops/sec ±3.59% (75 runs sampled) css =\u0026gt; table_header_traversing x 445 ops/sec ±3.71% (78 runs sampled) xpath =\u0026gt; table_header_traversing x 371 ops/sec ±4.41% (76 runs sampled) css =\u0026gt; table_header_traversing_and_direct_desc x 447 ops/sec ±4.69% (76 runs sampled) xpath =\u0026gt; table_header_traversing_and_direct_desc x 397 ops/sec ±1.95% (77 runs sampled) css =\u0026gt; table_cell_id_and_class x 460 ops/sec ±2.30% (81 runs sampled) xpath =\u0026gt; table_cell_id_and_class x 277 ops/sec ±1.69% (80 runs sampled) css =\u0026gt; table_cell_id_class_and_direct_desc x 418 ops/sec ±7.28% (71 runs sampled) xpath =\u0026gt; table_cell_id_class_and_direct_desc x 292 ops/sec ±2.51% (79 runs sampled) css =\u0026gt; table_cell_traversing x 488 ops/sec ±3.12% (80 runs sampled) xpath =\u0026gt; table_cell_traversing x 262 ops/sec ±1.40% (81 runs sampled) css =\u0026gt; table_cell_traversing_and_direct_desc x 430 ops/sec ±17.77% (71 runs sampled) xpath =\u0026gt; table_cell_traversing_and_direct_desc x 189 ops/sec ±30.31% (46 runs sampled) Firefox | MacOS Rapport graphique Css Vs Xpath - FireFox - MacOs Log benchmark-js css =\u0026gt; nested_sibling_traversal x 262 ops/sec ±5.21% (61 runs sampled) xpath =\u0026gt; nested_sibling_traversal x 202 ops/sec ±7.48% (56 runs sampled) css =\u0026gt; nested_sibling_traversal_by_class x 217 ops/sec ±5.19% (62 runs sampled) xpath =\u0026gt; nested_sibling_traversal_by_class x 76.43 ops/sec ±19.41% (54 runs sampled) css =\u0026gt; table_header_id_and_class x 311 ops/sec ±5.94% (60 runs sampled) xpath =\u0026gt; table_header_id_and_class x 290 ops/sec ±3.93% (63 runs sampled) css =\u0026gt; table_header_id_class_and_direct_desc x 308 ops/sec ±4.52% (58 runs sampled) xpath =\u0026gt; table_header_id_class_and_direct_desc x 350 ops/sec ±4.79% (58 runs sampled) css =\u0026gt; table_header_traversing x 345 ops/sec ±3.48% (57 runs sampled) xpath =\u0026gt; table_header_traversing x 260 ops/sec ±5.37% (61 runs sampled) css =\u0026gt; table_header_traversing_and_direct_desc x 326 ops/sec ±6.55% (59 runs sampled) xpath =\u0026gt; table_header_traversing_and_direct_desc x 261 ops/sec ±6.44% (56 runs sampled) css =\u0026gt; table_cell_id_and_class x 318 ops/sec ±14.41% (63 runs sampled) xpath =\u0026gt; table_cell_id_and_class x 228 ops/sec ±5.49% (60 runs sampled) css =\u0026gt; table_cell_id_class_and_direct_desc x 373 ops/sec ±4.20% (61 runs sampled) xpath =\u0026gt; table_cell_id_class_and_direct_desc x 247 ops/sec ±7.08% (50 runs sampled) css =\u0026gt; table_cell_traversing x 395 ops/sec ±7.69% (51 runs sampled) xpath =\u0026gt; table_cell_traversing x 212 ops/sec ±9.45% (60 runs sampled) css =\u0026gt; table_cell_traversing_and_direct_desc x 530 ops/sec ±3.74% (61 runs sampled) xpath =\u0026gt; table_cell_traversing_and_direct_desc x 377 ops/sec ±8.93% (50 runs sampled) Edge Chromium Edge Chromium | Linux Linux not supported\nEdge Chromium | Windows Rapport graphique Css Vs Xpath - Edge - Windows Log benchmark-js css =\u0026gt; nested_sibling_traversal x 165 ops/sec ±1.68% (80 runs sampled) xpath =\u0026gt; nested_sibling_traversal x 159 ops/sec ±1.80% (79 runs sampled) css =\u0026gt; nested_sibling_traversal_by_class x 198 ops/sec ±1.37% (82 runs sampled) xpath =\u0026gt; nested_sibling_traversal_by_class x 111 ops/sec ±1.60% (74 runs sampled) css =\u0026gt; table_header_id_and_class x 201 ops/sec ±1.42% (81 runs sampled) xpath =\u0026gt; table_header_id_and_class x 173 ops/sec ±1.48% (80 runs sampled) css =\u0026gt; table_header_id_class_and_direct_desc x 207 ops/sec ±1.42% (80 runs sampled) xpath =\u0026gt; table_header_id_class_and_direct_desc x 176 ops/sec ±1.25% (81 runs sampled) css =\u0026gt; table_header_traversing x 201 ops/sec ±1.29% (82 runs sampled) xpath =\u0026gt; table_header_traversing x 175 ops/sec ±1.67% (80 runs sampled) css =\u0026gt; table_header_traversing_and_direct_desc x 205 ops/sec ±1.20% (78 runs sampled) xpath =\u0026gt; table_header_traversing_and_direct_desc x 178 ops/sec ±1.90% (82 runs sampled) css =\u0026gt; table_cell_id_and_class x 201 ops/sec ±1.59% (78 runs sampled) xpath =\u0026gt; table_cell_id_and_class x 125 ops/sec ±7.14% (74 runs sampled) css =\u0026gt; table_cell_id_class_and_direct_desc x 206 ops/sec ±1.13% (79 runs sampled) xpath =\u0026gt; table_cell_id_class_and_direct_desc x 131 ops/sec ±2.08% (76 runs sampled) css =\u0026gt; table_cell_traversing x 201 ops/sec ±1.36% (80 runs sampled) xpath =\u0026gt; table_cell_traversing x 117 ops/sec ±2.00% (77 runs sampled) css =\u0026gt; table_cell_traversing_and_direct_desc x 203 ops/sec ±1.55% (79 runs sampled) xpath =\u0026gt; table_cell_traversing_and_direct_desc x 147 ops/sec ±2.04% (76 runs sampled) Edge Chromium | MacOS Rapport graphique Css Vs Xpath - Edge Chrome - MacOs Log benchmark-js css =\u0026gt; nested_sibling_traversal x 147 ops/sec ±2.61% (69 runs sampled) xpath =\u0026gt; nested_sibling_traversal x 113 ops/sec ±10.29% (65 runs sampled) css =\u0026gt; nested_sibling_traversal_by_class x 134 ops/sec ±9.37% (58 runs sampled) xpath =\u0026gt; nested_sibling_traversal_by_class x 102 ops/sec ±2.13% (71 runs sampled) css =\u0026gt; table_header_id_and_class x 189 ops/sec ±1.07% (71 runs sampled) xpath =\u0026gt; table_header_id_and_class x 160 ops/sec ±1.64% (72 runs sampled) css =\u0026gt; table_header_id_class_and_direct_desc x 188 ops/sec ±1.55% (70 runs sampled) xpath =\u0026gt; table_header_id_class_and_direct_desc x 155 ops/sec ±1.51% (69 runs sampled) css =\u0026gt; table_header_traversing x 191 ops/sec ±1.44% (71 runs sampled) xpath =\u0026gt; table_header_traversing x 153 ops/sec ±1.82% (66 runs sampled) css =\u0026gt; table_header_traversing_and_direct_desc x 178 ops/sec ±6.21% (69 runs sampled) xpath =\u0026gt; table_header_traversing_and_direct_desc x 152 ops/sec ±2.05% (69 runs sampled) css =\u0026gt; table_cell_id_and_class x 191 ops/sec ±2.11% (71 runs sampled) xpath =\u0026gt; table_cell_id_and_class x 112 ops/sec ±2.01% (66 runs sampled) css =\u0026gt; table_cell_id_class_and_direct_desc x 177 ops/sec ±2.53% (60 runs sampled) xpath =\u0026gt; table_cell_id_class_and_direct_desc x 120 ops/sec ±2.13% (56 runs sampled) css =\u0026gt; table_cell_traversing x 183 ops/sec ±1.78% (57 runs sampled) xpath =\u0026gt; table_cell_traversing x 94.47 ops/sec ±4.05% (57 runs sampled) css =\u0026gt; table_cell_traversing_and_direct_desc x 193 ops/sec ±1.17% (56 runs sampled) xpath =\u0026gt; table_cell_traversing_and_direct_desc x 140 ops/sec ±1.73% (54 runs sampled) Safari | MacOS Rapport graphique Log benchmark-js css =\u0026gt; nested_sibling_traversal x 267 ops/sec ±22.46% (71 runs sampled) xpath =\u0026gt; nested_sibling_traversal x 247 ops/sec ±14.10% (63 runs sampled) css =\u0026gt; nested_sibling_traversal_by_class x 145 ops/sec ±16.60% (36 runs sampled) xpath =\u0026gt; nested_sibling_traversal_by_class x 156 ops/sec ±14.84% (60 runs sampled) css =\u0026gt; table_header_id_and_class x 372 ops/sec ±2.14% (73 runs sampled) xpath =\u0026gt; table_header_id_and_class x 357 ops/sec ±0.75% (74 runs sampled) css =\u0026gt; table_header_id_class_and_direct_desc x 364 ops/sec ±12.31% (69 runs sampled) xpath =\u0026gt; table_header_id_class_and_direct_desc x 373 ops/sec ±3.05% (71 runs sampled) css =\u0026gt; table_header_traversing x 398 ops/sec ±0.70% (69 runs sampled) xpath =\u0026gt; table_header_traversing x 329 ops/sec ±9.59% (69 runs sampled) css =\u0026gt; table_header_traversing_and_direct_desc x 365 ops/sec ±5.18% (65 runs sampled) xpath =\u0026gt; table_header_traversing_and_direct_desc x 326 ops/sec ±9.83% (68 runs sampled) css =\u0026gt; table_cell_id_and_class x 356 ops/sec ±3.86% (70 runs sampled) xpath =\u0026gt; table_cell_id_and_class x 232 ops/sec ±4.65% (67 runs sampled) css =\u0026gt; table_cell_id_class_and_direct_desc x 349 ops/sec ±3.87% (69 runs sampled) xpath =\u0026gt; table_cell_id_class_and_direct_desc x 251 ops/sec ±4.13% (69 runs sampled) css =\u0026gt; table_cell_traversing x 349 ops/sec ±3.67% (74 runs sampled) xpath =\u0026gt; table_cell_traversing x 222 ops/sec ±4.97% (69 runs sampled) css =\u0026gt; table_cell_traversing_and_direct_desc x 349 ops/sec ±3.61% (71 runs sampled) xpath =\u0026gt; table_cell_traversing_and_direct_desc x 282 ops/sec ±4.20% (70 runs sampled) IE | Windows Rapport graphique Css Vs Xpath - FireFox - Windows Log benchmark-js css =\u0026gt; nested_sibling_traversal x 11.95 ops/sec ±2.58% (59 runs sampled) xpath =\u0026gt; nested_sibling_traversal x 16.89 ops/sec ±2.87% (79 runs sampled) css =\u0026gt; nested_sibling_traversal_by_class x 12.08 ops/sec ±1.37% (59 runs sampled) xpath =\u0026gt; nested_sibling_traversal_by_class x 7.23 ops/sec ±1.49% (39 runs sampled) css =\u0026gt; table_header_id_and_class x 11.93 ops/sec ±1.44% (59 runs sampled) xpath =\u0026gt; table_header_id_and_class x 17.24 ops/sec ±1.03% (80 runs sampled) css =\u0026gt; table_header_id_class_and_direct_desc x 12.11 ops/sec ±1.27% (60 runs sampled) xpath =\u0026gt; table_header_id_class_and_direct_desc x 17.17 ops/sec ±1.20% (80 runs sampled) css =\u0026gt; table_header_traversing x 12.30 ops/sec ±1.20% (60 runs sampled) xpath =\u0026gt; table_header_traversing x 17.39 ops/sec ±0.65% (73 runs sampled) css =\u0026gt; table_header_traversing_and_direct_desc x 12.47 ops/sec ±1.05% (61 runs sampled) xpath =\u0026gt; table_header_traversing_and_direct_desc x 17.47 ops/sec ±0.90% (81 runs sampled) css =\u0026gt; table_cell_id_and_class x 12.31 ops/sec ±1.25% (61 runs sampled) xpath =\u0026gt; table_cell_id_and_class x 17.56 ops/sec ±0.84% (45 runs sampled) css =\u0026gt; table_cell_id_class_and_direct_desc x 12.40 ops/sec ±1.21% (61 runs sampled) xpath =\u0026gt; table_cell_id_class_and_direct_desc x 17.46 ops/sec ±0.95% (47 runs sampled) css =\u0026gt; table_cell_traversing x 12.36 ops/sec ±1.47% (61 runs sampled) xpath =\u0026gt; table_cell_traversing x 10.77 ops/sec ±1.45% (54 runs sampled) css =\u0026gt; table_cell_traversing_and_direct_desc x 12.55 ops/sec ±1.21% (61 runs sampled) xpath =\u0026gt; table_cell_traversing_and_direct_desc x 13.05 ops/sec ±1.74% (63 runs sampled) Conclusion Voici les conclusions issues de ce benchmark:\nLes sélecteurs CSS sont légèrement plus rapide que ceux du Xpath, la seule exception en faveur d\u0026rsquo;Xpath et sans surprise le vieux navigateur IE Les sélecteurs CSS (et parfois Xpath) sont beaucoup plus rapide avec le navigateur Firefox notamment sur le système d\u0026rsquo;exploitation Linux et Windows, un peu moins rapide sur MacOS ( a priori grâce à l\u0026rsquo;intégration du moteur Quantum CSS) Certains sélecteurs CSS sont plus rapide avec Safari sur MacOS Les sélecteurs CSS et Xpath sont largement moins rapide sur le vieux navigateur IE Cette différence de performance Css Vs. Xpath est très loin d\u0026rsquo;être un élément essentiel pour réduire le temps d\u0026rsquo;exécution de vos tests UI Vous êtes maintenant bien armés avec des data à jour pour pouvoir choisir la meilleure stratégie de localisation webdriver.\nSi vous avez aimé cet article, n\u0026rsquo;hésitez pas à le partager !\n","permalink":"https://expandtesting.com/blog/css-vs-xpath-benchmark/","tags":["Webdriver","Benchmark","Testing"],"title":"Benchmark Css Vs Xpath"},{"categories":["Tests et Automatisation"],"contents":"Introduction Comme vous le savez les outils d\u0026rsquo;automatisation des tests UI comme Selenium , WebdriverIO , etc utilisent le même principe de fonctionnement et partagent les mêmes problématiques.\nTous les tests réalisés avec un outil webdriver sont principalement basés sur le contenu du DOM et utilisent les sélecteurs web pour interagir avec l\u0026rsquo;interface utilisateur via des drivers (chromedriver, geckodriver, etc.).\nCette réalité représente un vrai problème de dépendance entre les tests et la structure de l\u0026rsquo;interface utilisateur, un changement ainsi au niveau de l\u0026rsquo;UI implique une mise a jour a faire au niveau des tests.\nIl est donc essentiel de choisir soigneusement la meilleure stratégie pour résister au changement de l\u0026rsquo;interface utilisateur afin :\nde minimiser les coûts de maintenances d\u0026rsquo;augmenter la fiabilité des tests basés sur l\u0026rsquo;UI d\u0026rsquo;avoir un pipeline stable de livrer les produits le plus rapidement possible. Dans cet article je vais vous présenter les sélecteurs d\u0026rsquo;éléments web officiellement supportés par le W3C, évaluer leurs inconvénients et leurs avantages afin de vous aider à choisir la meilleure stratégie pour mener à bien votre projet d\u0026rsquo;automatisation d\u0026rsquo;UI.\nLe problème Sans trop entrer dans les détails techniques de chaque outil, framework ou api, le principe de fonctionnement simplifié est le suivant:\n1. Sélection de l\u0026rsquo;élément web (bouton, lien, menu déroulant, etc.) 2. Interaction avec l\u0026rsquo;élément sélectionné (simple clique, saisie d\u0026rsquo;un texte, récupération de texte, etc.) 3. Vérification des résultats à travers des assertions\nSouvent les tests échouent durant l\u0026rsquo;étape de sélection de l\u0026rsquo;élément web et vous perdrez donc le temps dans l\u0026rsquo;analyse des messages d\u0026rsquo;erreur de type:\nNot found exception An element could not be located on the page Unable to locate element NoSuchElementError X exception Après analyse des erreurs, vous vous rendez compte qu\u0026rsquo;une simple balise html div à été supprimée par les développeurs ou la valeur de l\u0026rsquo;ID à été mise à jour de: \u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;user\u0026quot; name=\u0026quot;user\u0026quot;\u0026gt; a \u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;username\u0026quot; name=\u0026quot;username\u0026quot;\u0026gt;\nCette problématique se multiplie notamment si les automaticiens et les développeurs ne sont pas dans la même équipe et / ou sans réelle collaboration.\nSans surprise, les résultats sont les suivants :\nTests non fiables (Flaky Tests) Coût de maintenance élevé Pipeline de livraison lent Perte de motivation La solution L\u0026rsquo;élément essentiel de la solution est la capacité d\u0026rsquo;identifier le bon sélecteur / sélecteur (locator).\nQu\u0026rsquo;est ce qu\u0026rsquo;un bon sélecteur ? Indépendamment du débat sur Xpath vs CSS, un bon sélecteur possède les caractéristiques suivantes:\nUnique Descriptif Faible probabilité de changement Les différentes stratégies webdriver Nous passons maintenant à l\u0026rsquo;analyse des différentes stratégies supportés par le W3C afin d\u0026rsquo;identifier la meilleure stratégie possible.\nPetit rappel de la liste des des stratégies officielles du W3C:\nCSS selector Link text selector Partial link text selector Tag name XPath selector Pour garder le focus sur l\u0026rsquo;essentiel et afin d\u0026rsquo;éviter d\u0026rsquo;entrer dans les détails de chaque stratégie qui ne sont pas nécessairement utiles, les différentes stratégies seront classés en grandes catégories:\nUne mauvaise stratégie: Link Text, Partial Link Text et Tag Name Une bonne stratégie: CSS et Xpath Une très bonne stratégie: ID et Class Une excellente stratégie: Attributs HTML personnalisés data-* avec les sélecteurs CSS Mauvaise: Link Text, Partial Link Text et Tag Name Les sélecteurs Link Text, Partial Link Text, et Tag Name ont le même problème, c\u0026rsquo;est le manque de résistance au changement qui peut avoir une page ou un composant html durant le cycle de vie d\u0026rsquo;un projet et donc les flaky tests !\nVoici un simple exemple pour mieux comprendre la problématique:\nSupposons que nous avons le code HTML suivant:\n\u0026lt;h1 class=\u0026quot;heading\u0026quot;\u0026gt;Welcome to the-internet\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;Available Examples\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;/upload\u0026quot;\u0026gt;File Upload\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;/floating_menu\u0026quot;\u0026gt;Floating Menu\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;/forgot_password\u0026quot;\u0026gt;Reset Password\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Maintenant pour automatiser notre scénario de test forgot_password, nous avons besoin de cliquer sur le lien /forgot_password, la solution la plus simple pour sélectionner l\u0026rsquo;élément web c\u0026rsquo;est d\u0026rsquo;utiliser la stratégie Link Text avec l\u0026rsquo;instruction selenium webdriver suivante await driver.findElement(By.linkText(\u0026quot;Reset Password\u0026quot;)).click() Bien, le test (click) devrait fonctionner !\nMaintenant le développeur repasse sur le code HTML, il trouve que Reset Password n\u0026rsquo;est pas trop sémantique et il serait super bien de changer le texte Reset Password par Forgot Password, un simple changement qui ne coûte rien !\nSuite à cette modification, nous avons donc le nouveau code html suivant:\n\u0026lt;h1 class=\u0026quot;heading\u0026quot;\u0026gt;Welcome to the-internet\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;Available Examples\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;/upload\u0026quot;\u0026gt;File Upload\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;/floating_menu\u0026quot;\u0026gt;Floating Menu\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;/forgot_password\u0026quot;\u0026gt;Forgot Password\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Nous exécutons à nouveau le même test forgot_password pour vérifier si tout va bien !\nExécution des tests en cours …\nBoom !\nLe test ne passe plus!, Ona la fameuse exception NoSuchElementException.\nVous devez comprendre maintenant que cette stratégie n\u0026rsquo;est pas la meilleure façon de faire ce travail, une telle stratégie axée sur le contenu est sans doute une mauvaise stratégie !\nUtilisez-les uniquement si vous avez un besoin spécifique et qu\u0026rsquo;aucune autre option n\u0026rsquo;est disponible !\nBonne: CSS et Xpath Indépendamment du débat sur Xpath vs CSS, ces deux sélecteurs sont conceptuellement très similaires, c\u0026rsquo;est pour cela je les ai rassemblés pour cette catégorie.\nXPath dispose la possibilité de sélectionner des éléments parents, cette option est particulièrement intéressante pour certains scénarios et CSS dispose une syntaxe relativement simple !\nQuelques points d\u0026rsquo;attention:\nCes types de sélecteurs avec des combinaisons de nom de balise, d\u0026rsquo;éléments descendants, de classe CSS (ou d\u0026rsquo;attribut d\u0026rsquo;élément) rendent le modèle de sélection strict ou lâche, ce qui signifie que de petites modifications HTML l\u0026rsquo;invalideront et perdront le sens qu\u0026rsquo;il pourrait correspondre à plus d\u0026rsquo;un élément HTML.\nLors de l\u0026rsquo;écriture d\u0026rsquo;un sélecteur Xpath ou CSS, il s\u0026rsquo;agit de trouver l\u0026rsquo;équilibre entre strict et lâche\nSuffisamment stable et durable pour résister au changement HTML\nSuffisamment strict pour échouer lorsque l\u0026rsquo;application échoue.\nXPath ne fonctionne pas correctement dans Internet Explorer.\nLes sélecteurs XPath absolus ne sont pas bons.\nTrès bonne: ID et Class L\u0026rsquo;ID est la stratégie de sélection la plus sûre et doit toujours être votre premier choix. Selon les normes du W3C, l\u0026rsquo;ID est sensé d\u0026rsquo;être unique dans la page (by design), il est également indépendant du type et de l\u0026rsquo;emplacement de l\u0026rsquo;élément web. Les navigateurs possèdent également des méthodes efficaces pour récupérer un objet sur une page en utilisant leurs identifiants.\nComme l\u0026rsquo;ID, l\u0026rsquo;utilisation de l\u0026rsquo;attribut Class a l\u0026rsquo;avantage d\u0026rsquo;être moins impacté par les changements structurels de la page web et donc plus stable.\nLorsque vous utilisez les deux stratégies ID et Class, vous cibler directement des éléments spécifiques au lieu de vous fier à la structure de la page.\nBien évidemment si le développeur modifier un ID ou un l\u0026rsquo;attribut Class qui est déjà utilisé dans le framework de tests UI automatisés cela aura un impact sur vos scénario de test tests. Comme je l\u0026rsquo;ai toujours dit, l\u0026rsquo;automatisation commence par la communication, discuter avec les développeurs c\u0026rsquo;est toujours important et nécessaire.\nExcellente: Attributs data-* avec les sélecteurs CSS Si vous avez la possibilité de collaborer avec les développeurs, la meilleure solution que je vous recommande très fortement est d\u0026rsquo;ajouter des attributs HTML personnalisés pour aider à identifier les éléments que vous devez sélectionner.\nC\u0026rsquo;est une pratique populaire pour industrialiser les tests d\u0026rsquo;acceptation basés sur l\u0026rsquo;interface utilisateur, cette stratégie peut vraiment vous aider à avoir des tests UI plus stable et de minimiser les coûts de maintenance.\nHTML5 a introduit un type d\u0026rsquo;attribut data-* formel dont nous pouvons tirer parti dans nos tests UI.\nC\u0026rsquo;est très simple à mettre en place, il suffit d\u0026rsquo;ajouter un attribut personnalisé à vos composants HTML. Cet attribut sera utilisé uniquement pour localiser les éléments web pour les besoins de tests d\u0026rsquo;acceptation au niveau de l\u0026rsquo;UI.\nVoici un simple exemple d\u0026rsquo;utilisation des attributs HTML personnalisés (data-testid):\nusername \u0026lt;form name=\u0026quot;login\u0026quot; id=\u0026quot;login\u0026quot; action=\u0026quot;/authenticate\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;large-6 small-12 columns\u0026quot;\u0026gt; \u0026lt;label for=\u0026quot;username\u0026quot;\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input data-testid=\u0026quot;username\u0026quot; type=\u0026quot;text\u0026quot; name=\u0026quot;username\u0026quot; id=\u0026quot;username\u0026quot; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;large-6 small-12 columns\u0026quot;\u0026gt; \u0026lt;label for=\u0026quot;password\u0026quot;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input data-testid=\u0026quot;password\u0026quot; type=\u0026quot;password\u0026quot; name=\u0026quot;password\u0026quot; id=\u0026quot;password\u0026quot; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button data-testid=\u0026quot;login-submit\u0026quot; class=\u0026quot;radius\u0026quot; type=\u0026quot;submit\u0026quot;\u0026gt; \u0026lt;i class=\u0026quot;fa fa-2x fa-sign-in\u0026quot;\u0026gt; Login\u0026lt;/i\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; Dans cet exemple (login), j\u0026rsquo;ai ajouté un attribut data-testid à tous les éléments web utilisés par les tests UI.\nCe n\u0026rsquo;était pas forcément nécessaire d\u0026rsquo;ajouter les attributs HTML personnalisés (car nous avons déjà les ID username, password pour les champs username, password et nous avons aussi la classe radius pour le bouton login, mais je l\u0026rsquo;ai fait exprès 😀\nVous vous posez peut-être la question \u0026ldquo;Pourquoi ?\u0026rdquo;\nLe véritable avantage de cela est qu\u0026rsquo;il est beaucoup moins susceptible d\u0026rsquo;être modifié au cours de la durée de vie du projet.\nLes autres attributs ID, name, class, etc. peuvent être changés par les développeurs et les raisons sont multiples:\nApplication des nouvelles règles de nommage Changement de style CSS Etc. Mais un attribut personnalisé nommé avec data-testid est beaucoup moins susceptible d\u0026rsquo;être modifié sans avertissement.\nNous allons maintenant compter sur nos attributs HTML personnalisés (data-testid) pour sélectionner d\u0026rsquo;une manière simple et efficace les éléments web pour nos tests UI.\nNous pouvons donc utiliser les sélecteurs suivants pour sélectionner les éléments nécessaires pour notre page login:\n[data-testid=\u0026quot;username\u0026quot;] [data-testid=\u0026quot;password\u0026quot;] [data-testid=\u0026quot;login-submit\u0026quot;] Mais pourquoi utiliser les sélecteurs CSS ?\nC\u0026rsquo;est simple, quand vous rencontrez une personne qui préfère parler anglais, le plus simple est de parler anglais avec lui ! C\u0026rsquo;est le même principe ici, les développeurs d\u0026rsquo;une manière générale préfèrent la simplicité du CSS.\nConclusion Le choix d\u0026rsquo;une stratégie de sélecteurs web est un élément essentiel au succès de l\u0026rsquo;automatisation des tests d\u0026rsquo;acceptation UI.\nIl faut garder à l\u0026rsquo;esprit qu\u0026rsquo;un bon sélecteur possède les caractéristiques:\nUnique Descriptif Faible probabilité de changement Assurez-vous de:\nCommencez par les deux stratégies ID et Class Utilisez les sélecteurs CSS (ou XPath) lorsque vous devez parcourir plusieurs éléments Discutez avec les développeurs pour trouver la meilleure solution possible L\u0026rsquo;utilisation des attributs data-* avec les sélecteurs CSS reste la meilleure solution pour minimiser les coûts de maintenance et limiter les flaky tests.\nSi vous avez aimé cet article, n\u0026rsquo;hésitez pas à le partager !\n","permalink":"https://expandtesting.com/blog/strategie-selecteurs-web-css-xpath/","tags":["Webdriver","Testing"],"title":"Comment choisir une stratégie de sélecteurs web (CSS/XPath) ?"},{"categories":["Programmation"],"contents":"Introduction Dans mon précédent article j’ai expliqué le quatrième principe SOLID (Ségrégation d’interface).\nN’hésitez pas a découvrir les autres principes SOLID dans cette série d\u0026rsquo;articles:\nSRP: Responsabilité unique OCP: Ouvert-Fermé LSP: Substitution de Liskov ISP: Ségrégation d’interface Aujourd\u0026rsquo;hui je vous propose une explication pour le cinquième principe S.O.L.I.D, c’est le principe «Inversion De Dépendance» (Dependency Inversion), ce principe est basé sur les affirmations suivantes:\nLes modules de haut niveau ne devraient pas dépendre des modules de bas niveau, tous deux devraient dépendre d’abstraction. Les abstractions ne devraient pas dépendre de détails, ce sont les détails qui devraient dépendre des abstractions. On comprend mieux avec un exemple!\nUn mauvais exemple public sealed class Customer { public int Id { get; set; } public string Name { get; set; } } public sealed class CustomerRepository { public CustomerRepository(string dbConnectionString) { // Some implementation here } public void AddCustomer(Customer customer) { // Some implementation here (database) } } public sealed class CustomerService { private CustomerRepository _customerRepository = new CustomerRepository(\u0026quot;dbConnectionString\u0026quot;); public void Add(Customer customer) { _customerRepository.AddCustomer(customer); } Le code est incorrect car la classe CustomerService dépend de la classe CustomerRepository et sait également comment l\u0026rsquo;instancier.\nUn bon exemple public sealed class Customer { public int Id { get; set; } public string Name { get; set; } } public interface ICustomerRepository { void AddCustomer(Customer customer); } public sealed class CustomerRepository : ICustomerRepository { public CustomerRepository(string dbConnectionString) { // Some implementation here } public void AddCustomer(Customer customer) { // Some implementation here (database) } } public sealed class CustomerService { private ICustomerRepository CustomerRepository { get; } public CustomerService(ICustomerRepository customerRepository) { CustomerRepository = customerRepository; } public void AddCustomer(Customer customer) { CustomerRepository.Add(customer); } } Le code est correct car la classe CustomerService ne dépend que de l\u0026rsquo;interface ICustomerRepository, elle ne connaît pas l\u0026rsquo;implémentation ni comment l\u0026rsquo;instancier.\nSi vous avez aimé cet article, n\u0026rsquo;hésitez pas à le partager !\n","permalink":"https://expandtesting.com/blog/principes-solid-simplifies-inversion-de-dependance/","tags":["SOLID","POO","Design Patterns"],"title":"Principes SOLID simplifiés (5/5): Inversion De Dépendance"},{"categories":["Programmation"],"contents":"Introduction Dans mon précédent article j’ai expliqué le troisième principe SOLID (Substitution de Liskov).\nN’hésitez pas a découvrir les autres principes SOLID dans cette série d\u0026rsquo;articles:\nSRP: Responsabilité unique OCP: Ouvert-Fermé LSP: Substitution de Liskov DIP: Inversion De Dépendance Aujourd\u0026rsquo;hui je vous propose une explication pour le quatrième principe S.O.L.I.D, c’est le principe «Ségrégation d’interface» (Interface Segregation), ce principe affirme qu\u0026rsquo;il vaut mieux plusieurs interfaces spécifiques à une classe qu’une grosse interface générique, il ne faut pas obliger à implémenter des méthodes que l’on ne veut pas.\nJe vous donne un exemple:\nUn mauvais exemple public interface IBase { void UpdateId(int id); void UpdateAddress(string address); void UpdatePrice(decimal price); } public sealed class Customer : IBase { public int Id { get; set; } public string Name { get; set; } public string Address { get; set; } public void UpdateId(int id) { Id = id; } public void UpdateAddress(string address) { Address = address; } public void UpdatePrice(decimal price) { throw new NotImplementedException(); } } public sealed class Product : IBase { public int Id { get; set; } public string Description { get; set; } public decimal Price { get; set; } public void UpdateId(int id) { Id = id; } public void UpdatePrice(decimal price) { Price = price; } public void UpdateAddress(string address) { throw new NotImplementedException(); } } Le code est incorrect car la classe Customer doit avoir la méthode UpdatePrice et la classe Product doit avoir la méthode UpdateAddress parce qu\u0026rsquo;ils implémentent la même interface IBase.\nUn bon exemple public interface IBase { void UpdateId(int id); } public interface ICustomer : IBase { void UpdateAddress(string address); } public interface IProduct : IBase { void UpdatePrice(decimal price); } public sealed class Customer : ICustomer { public int Id { get; set; } public string Name { get; set; } public string Address { get; set; } public void UpdateId(int id) { Id = id; } public void UpdateAddress(string address) { Address = address; } } public sealed class Product : IProduct { public int Id { get; set; } public string Description { get; set; } public decimal Price { get; set; } public void UpdateId(int id) { Id = id; } public void UpdatePrice(decimal price) { Price = price; } } Le code est correct car l\u0026rsquo;interface générique a été divisée en interfaces spécifiques.\nLes classes Customer et Product n\u0026rsquo;implémentent pas de méthodes qui ne font pas partie de la même logique métier.\nSi vous avez aimé cet article, n\u0026rsquo;hésitez pas à le partager !\n","permalink":"https://expandtesting.com/blog/principes-solid-simplifies-segregation-interface/","tags":["SOLID","POO","Design Patterns"],"title":"Principes SOLID simplifiés (4/5): Ségrégation d’interface"},{"categories":["Programmation"],"contents":"Introduction Dans mon précédent article j’ai expliqué le deuxième principe SOLID (Ouvert-Fermé).\nN’hésitez pas a découvrir les autres principes SOLID dans cette série d\u0026rsquo;articles:\nSRP: Responsabilité unique OCP: Ouvert-Fermé ISP: Ségrégation d’interface DIP: Inversion De Dépendance Aujourd\u0026rsquo;hui je vous propose une explication pour le troisième principe S.O.L.I.D, c’est le principe «Substitution de Liskov» (Liskov Substitution), ce principe affirme que les classes dérivées doivent être substituables à leurs classes de base.\nJe vous donne un mauvais exemple pour montrer la voilation du principe Substitution de Liskov:\nUn mauvais exemple public class Cat { public virtual string GetName() { return nameof(Cat); } public void Move() { // Some implementation heren } public void Eat() { // Some implementation heren } } public class Dog : Cat { public override string GetName() { return nameof(Dog); } } public static class Program { public static void Main() { Cat cat = new Dog(); cat.GetName(); } } Le code est incorrect car l\u0026rsquo;exécution de la méthode \u0026ldquo;cat.GetName ()\u0026rdquo; affichera \u0026ldquo;Dog\u0026rdquo; et non \u0026ldquo;Cat\u0026rdquo; comme prévu\nUn bon exemple public abstract class Animal { public abstract string GetName(); public virtual void Move() { // Some implementation here } public void Eat() { // Some implementation here } } public sealed class Cat : Animal { public override string GetName() { return nameof(Cat); } } public sealed class Dog : Animal { public override string GetName() { return nameof(Dog); } public override void Move() { // Some implementation here } } public static class Program { public static void Main() { var animals = new List\u0026lt;Animal\u0026gt; { new Cat(), new Dog() }; foreach (var animal in animals) { animal.GetName(); animal.Move(); animal.Eat(); } } } Le code est correct car les deux classes Cat et Dog peuvent être remplacées par la classe Animal sans avoir de comportements inattendus.\nSi vous avez aimé cet article, n\u0026rsquo;hésitez pas à le partager ! n\u0026rsquo;hésitez pas à le partager !\n","permalink":"https://expandtesting.com/blog/principes-solid-simplifies-substitution-de-liskov/","tags":["SOLID","POO","Design Patterns"],"title":"Principes SOLID simplifiés (3/5): Substitution de Liskov"},{"categories":["Programmation"],"contents":"Introduction Dans un précédent article j’ai évoqué le premier principe S.O.L.I.D (Responsabilité unique).\nN’hésitez pas a découvrir les autres principes SOLID dans cette série d\u0026rsquo;articles:\nSRP: Responsabilité unique LSP: Substitution de Liskov ISP: Ségrégation d’interface DIP: Inversion De Dépendance Maintenant je vous propose une explication pour le deuxième principe S.O.L.I.D, c’est le principe «Ouvert-Fermé» (Open/Closed), ce principe affirme qu\u0026rsquo;une classe doit être à la fois ouverte à l\u0026rsquo;extension et fermée à la modification.\nJe vous donne un exemple:\nUn mauvais exemple public enum PaymentMethod { VisaCard = 1, MasterCard = 2, Cash = 3, } public class PaymentService { public PaymentMethod PaymentMethod { get; set; } public void ProcessPayment() { if (PaymentMethod == PaymentMethod.VisaCard) { // Some implementation heren } else if (PaymentMethod == PaymentMethod.MasterCard) { // Some implementation heren } else if (PaymentMethod == PaymentMethod.Cash) { // Some implementation here } // Some implementation here } } Le code est incorrect car il est ouvert à la modification, si un nouveau mode de paiement est ajouté, la classe doit être modifiée.\nUn bon exemple public interface IPaymentMethod { void ProcessPayment(); } public sealed class VisaCardPayment : IPaymentMethod { public void ProcessPayment() { // Some implementation here (VisaCardPayment) } } public sealed class MasterCardPayment : IPaymentMethod { public void ProcessPayment() { // Some implementation here (MasterCardPayment) } } public sealed class CashPayment : IPaymentMethod { public void ProcessPayment() { // Some implementation here (CashPayment) } } public class PaymentService { public PaymentService(IPaymentMethod paymentMethod) { PaymentMethod = paymentMethod; } private IPaymentMethod PaymentMethod { get; } public void ProcessPayment() { // Some implementation here PaymentMethod.ProcessPayment(); // Some implementation here } } Le code est correct car si un nouveau mode de paiement est ajouté, la classe n\u0026rsquo;est pas modifiée.\nSi vous avez aimé cet article, n\u0026rsquo;hésitez pas à le partager !\n","permalink":"https://expandtesting.com/blog/principes-solid-simplifies-ouvert-ferme/","tags":["SOLID","POO","Design Patterns"],"title":"Principes SOLID simplifiés (2/5): Ouvert-Fermé"},{"categories":["Programmation"],"contents":"Les principes S.O.L.I.D dans le contexte de l\u0026rsquo;automatisation des tests L\u0026rsquo;acronyme S.O.L.I.D a été inventé par Michael Feathers à partir des principes de programmation orientée objet identifiés par Robert Cecil Martin, Ces principes visent à rendre le code plus lisible, facile à maintenir, extensible, réutilisable et sans répétition.\nL\u0026rsquo;automatisation des tests c’est un vrai projet de développement et lorsque les principes S.O.L.I.D ne sont pas appliqués le code devient difficile à maintenir ou à faire évoluer.\nDans cet article, je vous propose une explication du principe Responsabilité unique (Single Responsibility)\nN’hésitez pas a découvrir les autres principes SOLID dans cette série d\u0026rsquo;articles:\nOCP: Ouvert-Fermé LSP: Substitution de Liskov ISP: Ségrégation d’interface DIP: Inversion De Dépendance Le principe de responsabilité unique stipule qu\u0026rsquo;une classe ne devrait avoir qu\u0026rsquo;une seule raison de changer et une seule responsabilité.\nOn comprend toujours mieux avec un exemple!\nUn mauvais exemple public sealed class Customer { public int Id { get; set; } public string Name { get; set; } public bool Active { get; set; } public void ActivateCustomer() { Active = true; } public void InactivateCustomer() { Active = false; } public void AddCustomer() { // Some implementation here (database) ... } public void DeleteCustomer() { // Some implementation here (database) ... } } Le code de l\u0026rsquo;exemple est incorrect car il a deux responsabilités, les règles de gestion et la persistance de la base de données.\nUn bon exemple public sealed class Customer { public int Id { get; set; } public string Name { get; set; } public bool Active { get; set; } public void ActivateCustomer() { Active = true; } public void InactivateCustomer() { Active = false; } } public sealed class CustomerRepository { public void AddCustomer(Customer customer) { // Some implementation here (database) ... } public void DeleteCustomer(Customer customer) { // Some implementation here (database) ... } } Le code est correct car les responsabilités ont été réparties et chaque classe n\u0026rsquo;a qu\u0026rsquo;une seule raison de changer.\nSi vous avez aimé cet article, n\u0026rsquo;hésitez pas à le partager !\n","permalink":"https://expandtesting.com/blog/principes-solid-simplifies-responsabilite-unique/","tags":["SOLID","POO","Design Patterns"],"title":"Principes SOLID simplifiés (1/5): Responsabilité unique"},{"categories":null,"contents":"Votre message a été envoyé avec succès, nous vous contacterons dans les plus brefs délais. Merci !\n","permalink":"https://expandtesting.com/confirmation-contact/","tags":null,"title":"Confirmation de votre contact"},{"categories":null,"contents":" Coach et formateur expert en automatisation des tests web et mobiles avec une double compétence en développements et testing\n","permalink":"https://expandtesting.com/auteurs/tawfik-nouri/","tags":null,"title":"Tawfik Nouri"},{"categories":null,"contents":"À propos de moi Formateur expert en automatisation des tests web et mobiles avec une double compétence en développements et testing.\nFormateur Selenium Webdriver Formateur Cypress Formateur Playwright Foemateur Appium Formateur K6 (tests de performance) N\u0026rsquo;hésitez pas à me contacter pour vos besoins en expertise et formation sur les tests logiciels.\n","permalink":"https://expandtesting.com/formateurs/tawfik-nouri/","tags":null,"title":"Tawfik Nouri"}]